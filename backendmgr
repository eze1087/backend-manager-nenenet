#!/usr/bin/env bash
set -Eeuo pipefail

APP_NAME="Backend Manager Nenenet 3.0"
APP_VER="4.5"

# ------------------ RUTAS ------------------
CFG_DIR="/etc/backendmgr"
CFG_FILE="${CFG_DIR}/config.json"

NGX_DIR="/etc/nginx/conf.d/backendmgr"
SERVERS_DIR="${NGX_DIR}/servers"

NGX_BACKENDS_MAP="${NGX_DIR}/backends.map"
NGX_APPLY_SNIP="${NGX_DIR}/apply.conf"
NGX_MAIN_INCLUDE="${NGX_DIR}/backendmgr.conf"

# Balance
NGX_BALANCER_CONF="${NGX_DIR}/balancer.conf"
NGX_BALANCED_MAP="${NGX_DIR}/balanced.map"

# Speed limits
NGX_LIMITS_IP="${NGX_DIR}/limits_ip.map"
NGX_LIMITS_BACKEND="${NGX_DIR}/limits_backend.map"
NGX_LIMITS_URL="${NGX_DIR}/limits_url.map"

# backups en /etc/nginx (misma ubicaci√≥n)
BACKUP_DIR="/etc/nginx/backendmgr-backups"

# Logs
PANEL_LOG="/var/log/backendmgr.panel.log"
WRAPPER_LOG="/var/log/backendmgr.wrapper.log"

# ------------------ COLORES ------------------
NC='\033[0m'
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
CYA='\033[0;36m'
WHT='\033[1;37m'
DIM='\033[2m'

# ------------------ TTY + TRAPS ------------------
mkdir -p /var/log 2>/dev/null || true

# Forzar TTY para que SIEMPRE se vea el men√∫ al llamar con nginx
if [[ -r /dev/tty && -w /dev/tty ]]; then
  exec </dev/tty >/dev/tty 2>&1
fi

on_err() {
  local rc=$?
  echo -e "${RED}‚ùå ERROR:${NC} backendmgr rc=${rc} | l√≠nea ${LINENO} | cmd: ${BASH_COMMAND}" | tee -a "$PANEL_LOG" >/dev/null
  echo -e "${YLW}üìå Log:${NC} ${PANEL_LOG}"
  exit "$rc"
}
trap on_err ERR

# Debug opcional:
# BACKENDMGR_DEBUG=1 nginx
if [[ "${BACKENDMGR_DEBUG:-0}" == "1" ]]; then
  exec 3>>"$PANEL_LOG"
  BASH_XTRACEFD=3
  set -x
fi

# ------------------ HELPERS ------------------
need_root() { [[ ${EUID:-999} -eq 0 ]] || { echo -e "${RED}ERROR:${NC} ejecut√°: sudo nginx"; exit 1; }; }
pause() { echo; read -r -p "Enter para volver al men√∫..." _; }

ensure_jq() {
  if command -v jq >/dev/null 2>&1; then return 0; fi
  echo -e "${YLW}‚ö†Ô∏è Falta jq.${NC} Intento instalarlo..."
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y >/dev/null 2>&1 || true
  apt-get install -y jq >/dev/null 2>&1 || true
  command -v jq >/dev/null 2>&1 || { echo -e "${RED}ERROR:${NC} no pude instalar jq. Hac√©: apt install -y jq"; exit 1; }
}

write_default_cfg() {
  mkdir -p "$CFG_DIR"
  cat > "$CFG_FILE" <<'JSON'
{
  "header_name": "Backend",
  "primary_domain": "",
  "rate_limit_enabled": true,
  "rate_limit_rate": "10r/s",
  "rate_limit_burst": 20,
  "conn_limit": 30,
  "curl_timeout_seconds": 8,
  "traffic_window_seconds": 60,
  "stats_log_path": "/var/log/nginx/backendmgr.stats.log",
  "balance_mode": "off",
  "balance_max_slots_cap": 64
}
JSON
}

ensure_cfg() {
  [[ -f "$CFG_FILE" ]] || write_default_cfg
}

ensure_files() {
  mkdir -p "$NGX_DIR" "$SERVERS_DIR" "$BACKUP_DIR" /var/log/nginx /var/lib/backendmgr
  chmod 700 "$BACKUP_DIR" || true

  [[ -f "$NGX_BACKENDS_MAP" ]] || : > "$NGX_BACKENDS_MAP"
  [[ -f "$NGX_APPLY_SNIP" ]] || : > "$NGX_APPLY_SNIP"
  [[ -f "$NGX_BALANCER_CONF" ]] || : > "$NGX_BALANCER_CONF"
  [[ -f "$NGX_BALANCED_MAP" ]] || : > "$NGX_BALANCED_MAP"

  [[ -f "$NGX_LIMITS_IP" ]] || : > "$NGX_LIMITS_IP"
  [[ -f "$NGX_LIMITS_BACKEND" ]] || : > "$NGX_LIMITS_BACKEND"
  [[ -f "$NGX_LIMITS_URL" ]] || : > "$NGX_LIMITS_URL"
}

read_cfg() {
  [[ -f "$CFG_FILE" ]] || { echo -e "${RED}Falta ${CFG_FILE}.${NC} Reinstal√° con install.sh"; exit 1; }

  HEADER_NAME="$(jq -r '.header_name' "$CFG_FILE")"
  PRIMARY_DOMAIN="$(jq -r '.primary_domain' "$CFG_FILE")"
  [[ "$PRIMARY_DOMAIN" == "null" ]] && PRIMARY_DOMAIN=""

  RL_ENABLED="$(jq -r '.rate_limit_enabled' "$CFG_FILE")"
  RL_RATE="$(jq -r '.rate_limit_rate' "$CFG_FILE")"
  RL_BURST="$(jq -r '.rate_limit_burst' "$CFG_FILE")"
  CONN_LIMIT="$(jq -r '.conn_limit' "$CFG_FILE")"

  CURL_TMO="$(jq -r '.curl_timeout_seconds' "$CFG_FILE")"
  WINDOW_SEC="$(jq -r '.traffic_window_seconds' "$CFG_FILE")"
  STATS_LOG="$(jq -r '.stats_log_path' "$CFG_FILE")"

  BAL_MODE="$(jq -r '.balance_mode' "$CFG_FILE")"
  BAL_CAP="$(jq -r '.balance_max_slots_cap' "$CFG_FILE")"
  [[ "$BAL_CAP" == "null" || -z "$BAL_CAP" ]] && BAL_CAP="64"
}

nginx_test_reload() {
  if ! timeout 10s nginx -t; then
    echo -e "${YLW}‚ö†Ô∏è nginx -t fall√≥. No recargo.${NC}"
    return 0
  fi
  timeout 8s nginx -s reload >/dev/null 2>&1 || true
  return 0
}

banner() {
  clear || true
  echo -e "${CYA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${CYA}‚ïë${NC}  üöÄ ${APP_NAME} v${APP_VER}                                     ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïë${NC}  Dominio madre: ${WHT}${PRIMARY_DOMAIN:-"(no configurado)"}${NC} | Header: ${WHT}${HEADER_NAME}${NC} ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïë${NC}  Balance: ${WHT}${BAL_MODE}${NC} | Stats: ${WHT}${STATS_LOG}${NC} ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo
}

backend_lines() { grep -E '^\s*"[A-Za-z0-9_.:-]+"\s+"http://' "$NGX_BACKENDS_MAP" 2>/dev/null || true; }
server_files() { ls -1 "${SERVERS_DIR}"/*.conf 2>/dev/null || true; }

validate_domain() { [[ "$1" =~ ^[A-Za-z0-9.-]{3,253}$ ]]; }
validate_key() { [[ "$1" =~ ^[A-Za-z0-9_.:-]{2,64}$ ]]; }
validate_ip() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }
validate_rate() { [[ "$1" == "0" || "$1" =~ ^[0-9]+[kKmM]$ ]]; }

# ------------------ APPLY.CONF (rate + balance + speed) ------------------
write_apply_conf() {
  read_cfg

  cat > "$NGX_APPLY_SNIP" <<EOF
# ${APP_NAME} apply.conf
access_log ${STATS_LOG} backendmgr_stats;

# Balance: si est√° activo, pisa backend_url por el balanceado
if (\$backendmgr_balance = 1) {
    set \$backend_url \$balanced_backend_url;
}

EOF

  if [[ "$RL_ENABLED" == "true" ]]; then
    cat >> "$NGX_APPLY_SNIP" <<EOF
limit_req zone=backendmgr_req burst=${RL_BURST} nodelay;
limit_conn backendmgr_conn ${CONN_LIMIT};

EOF
  else
    cat >> "$NGX_APPLY_SNIP" <<'EOF'
# rate-limit desactivado
EOF
  fi

  cat >> "$NGX_APPLY_SNIP" <<'EOF'

# Speed limits (0 = unlimited)
# prioridad: Backend(key) > URL(actual) > IP
set $nenenet_rate 0;

if ($backend_limit_rate != 0) { set $nenenet_rate $backend_limit_rate; }
if ($nenenet_rate = 0) { if ($url_limit_rate != 0) { set $nenenet_rate $url_limit_rate; } }
if ($nenenet_rate = 0) { if ($ip_limit_rate != 0) { set $nenenet_rate $ip_limit_rate; } }

limit_rate $nenenet_rate;
EOF
}

# ------------------ BALANCE ------------------
rebuild_balancer_files() {
  read_cfg
  local cap="$BAL_CAP"
  [[ "$cap" =~ ^[0-9]+$ ]] || cap=64

  : > "$NGX_BALANCED_MAP"
  local i=0
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    printf "    \"%s\" \"%s\";\n" "$i" "$url" >> "$NGX_BALANCED_MAP"
    i=$((i+1))
    [[ $i -ge $cap ]] && break
  done < <(backend_lines)

  if [[ $i -lt 2 || "$BAL_MODE" == "off" ]]; then
    cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (balance OFF)
map $host $backendmgr_balance { default 0; }
map $host $backendmgr_slot { default "0"; }

map $backendmgr_slot $balanced_backend_url {
    default $backend_url;
    include /etc/nginx/conf.d/backendmgr/balanced.map;
}
EOF
    return 0
  fi

  local base=$((100 / i))
  local rem=$((100 - base * i))

  local split_key='$remote_addr'
  [[ "$BAL_MODE" == "random" ]] && split_key='$remote_addr$msec$connection'

  {
    echo "# backendmgr balancer.conf (balance: ${BAL_MODE})"
    echo "map \$host \$backendmgr_balance { default 1; }"
    echo "split_clients \"${split_key}\" \$backendmgr_slot {"
    for ((n=0;n<i;n++)); do
      pct="$base"
      if (( rem > 0 )); then pct=$((pct+1)); rem=$((rem-1)); fi
      echo "    ${pct}% \"${n}\";"
    done
    echo "}"
    echo "map \$backendmgr_slot \$balanced_backend_url {"
    echo "    default \$backend_url;"
    echo "    include ${NGX_BALANCED_MAP};"
    echo "}"
  } > "$NGX_BALANCER_CONF"
}

set_balance_mode() {
  echo -e "${CYA}Balanceador (equilibrar tr√°fico)${NC}"
  echo -e "${DIM}OFF = tu modo (por header). RANDOM = reparte. STICKY-IP = por IP.${NC}\n"
  echo "1) OFF"
  echo "2) RANDOM"
  echo "3) STICKY-IP"
  read -r -p "Opci√≥n: " op
  case "$op" in
    1) new="off" ;;
    2) new="random" ;;
    3) new="iphash" ;;
    *) echo "Inv√°lida"; return 0 ;;
  esac

  jq --arg v "$new" '.balance_mode=$v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
  read_cfg
  rebuild_balancer_files
  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ Balance: ${new}${NC}"
}

# ------------------ SPEED LIMIT ------------------
map_set_line() {
  local file="$1" key="$2" val="$3" mode="$4"
  local k="$key"
  [[ "$mode" == "quote" ]] && k="\"$key\""

  awk -v k="$k" '{ if($0 ~ "^[ \t]*"k"[ \t]+"){ next } print }' "$file" > "${file}.tmp" || true

  if [[ "$val" != "0" ]]; then
    printf "    %s %s;\n" "$k" "$val" >> "${file}.tmp"
  fi
  mv "${file}.tmp" "$file"
}

speed_limit_menu() {
  echo -e "${CYA}Limitar ancho de banda (limit_rate)${NC}"
  echo -e "${DIM}Formato: 512k, 2m, 10m. 0 = sin l√≠mite.${NC}\n"
  echo "1) Limitar por IP"
  echo "2) Limitar por Backend"
  echo "3) Limpiar l√≠mites (IP y Backend)"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1)
      read -r -p "IP: " ip
      validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return 0; }
      read -r -p "Velocidad (ej 2m, 512k, 0=unlimited): " rate
      validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return 0; }
      map_set_line "$NGX_LIMITS_IP" "$ip" "$rate" "noquote"
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ OK.${NC}"
      ;;
    2)
      read -r -p "Backend (ej svpnene38): " key
      validate_key "$key" || { echo -e "${RED}Backend inv√°lido.${NC}"; return 0; }
      read -r -p "Velocidad (ej 2m, 512k, 0=unlimited): " rate
      validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return 0; }
      map_set_line "$NGX_LIMITS_BACKEND" "$key" "$rate" "quote"
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ OK.${NC}"
      ;;
    3)
      : > "$NGX_LIMITS_IP"
      : > "$NGX_LIMITS_BACKEND"
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ L√≠mites limpiados.${NC}"
      ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ------------------ LISTAS / PICKS ------------------
pick_domain() {
  mapfile -t files < <(server_files)
  [[ "${#files[@]}" -gt 0 ]] || { echo -e "${YLW}No hay dominios madre creados.${NC}"; return 1; }

  echo -e "${CYA}Elegir dominio madre:${NC}"
  local i=0
  for f in "${files[@]}"; do
    i=$((i+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
    printf "%-3s) %s\n" "$i" "$dom"
  done
  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#files[@]} )) || return 1
  PICKED_DOMAIN_FILE="${files[$((n-1))]}"
  PICKED_DOMAIN="$(grep -E '^\s*server_name\s+' "$PICKED_DOMAIN_FILE" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
  [[ -n "${PICKED_DOMAIN:-}" ]] || return 1
  return 0
}

pick_backend() {
  mapfile -t lines < <(backend_lines)
  [[ "${#lines[@]}" -gt 0 ]] || { echo -e "${YLW}No hay backends cargados.${NC}"; return 1; }

  echo -e "${CYA}Elegir backend:${NC}"
  local i=0
  for line in "${lines[@]}"; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-3s) %-20s -> %s:%s\n" "$i" "$key" "$ip" "$port"
  done
  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#lines[@]} )) || return 1

  line="${lines[$((n-1))]}"
  PICKED_BACKEND="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
  PICKED_BACKEND_URL="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
  [[ -n "${PICKED_BACKEND:-}" ]] || return 1
  return 0
}

# ------------------ DOMINIO MADRE / SERVER ------------------
create_server_for_domain() {
  local dom="$1"
  local file="${SERVERS_DIR}/${dom}.conf"
  local safe="${dom//./_}"

  # defaults exactos (300/600/600)
  local cto="${2:-300s}"
  local sto="${3:-600s}"
  local rto="${4:-600s}"

  cat > "$file" <<EOF
server {
    listen 80;
    listen [::]:80;

    server_name ${dom};

    access_log /var/log/nginx/${safe}.access.log;
    error_log  /var/log/nginx/${safe}.error.log;

    # Opcional: timeouts largos para backend
    proxy_connect_timeout ${cto};
    proxy_send_timeout    ${sto};
    proxy_read_timeout    ${rto};

    location / {
        proxy_pass \$backend_url;

        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        include /etc/nginx/conf.d/backendmgr/apply.conf;
    }
}
EOF
}

add_domain_auto_create() {
  echo -e "${CYA}Agregar dominio madre (AUTO crea server)${NC}"
  echo -e "${DIM}Ejemplo: cpu2.nenenet.site${NC}\n"
  read -r -p "Dominio madre nuevo: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return 0; }

  create_server_for_domain "$dom" "300s" "600s" "600s"
  write_apply_conf
  rebuild_balancer_files
  nginx_test_reload
  echo -e "${GRN}‚úÖ Dominio madre creado:${NC} ${dom} (80)"
  echo -e "${DIM}Tip: si quer√©s editar timeouts, opci√≥n 9.${NC}"
}

create_or_edit_server_http() {
  echo -e "${CYA}Editar dominio madre (timeouts)${NC}"
  echo -e "${DIM}Enter = default 300/600/600.${NC}\n"

  read -r -p "Dominio (ej: cpu2.elnene.site): " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return 0; }

  read -r -p "proxy_connect_timeout (Enter=300s): " cto
  read -r -p "proxy_send_timeout    (Enter=600s): " sto
  read -r -p "proxy_read_timeout    (Enter=600s): " rto
  cto="${cto:-300s}"; sto="${sto:-600s}"; rto="${rto:-600s}"

  create_server_for_domain "$dom" "$cto" "$sto" "$rto"
  write_apply_conf
  rebuild_balancer_files
  nginx_test_reload
  echo -e "${GRN}‚úÖ Actualizado:${NC} ${dom}"
}

list_domains() {
  echo -e "${CYA}Dominios madre (servers)${NC}\n"
  mapfile -t files < <(server_files)
  [[ "${#files[@]}" -gt 0 ]] || { echo -e "${YLW}No hay dominios creados.${NC}"; return 0; }

  local idx=0
  for f in "${files[@]}"; do
    idx=$((idx+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/')"
    echo "$idx) $dom"
  done
}

# ------------------ BACKENDS ------------------
add_backend() {
  echo -e "${CYA}Agregar backend (nombre + IP + puerto)${NC}"
  echo -e "${DIM}Ejemplo: svpnene38 -> 179.43.112.38:80${NC}\n"

  read -r -p "Nombre del backend (ej: svpnene38): " key
  validate_key "$key" || { echo -e "${RED}Nombre inv√°lido.${NC}"; return 0; }

  read -r -p "IP (ej: 179.43.112.38): " ip
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return 0; }

  read -r -p "Puerto (ej: 80): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return 0; }

  local url="http://${ip}:${port}"

  if grep -qE "^\s*\"${key}\"" "$NGX_BACKENDS_MAP"; then
    awk -v k="$key" -v url="$url" '{re="^[ \t]*\""k"\""; if($0~re){sub(/\"http:\\/\\/[^\\\"]+\"/, "\""url"\"")} print}' \
      "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
    echo -e "${GRN}‚úÖ Actualizado:${NC} $key -> $ip:$port"
  else
    printf "        \"%s\" \"%s\";\n" "$key" "$url" >> "$NGX_BACKENDS_MAP"
    echo -e "${GRN}‚úÖ Agregado:${NC} $key -> $ip:$port"
  fi

  rebuild_balancer_files
  write_apply_conf
  nginx_test_reload
}

list_backends() {
  echo -e "${CYA}Backends (backend / IP / puerto)${NC}\n"
  printf "%-4s %-22s %-18s %-6s\n" "#" "BACKEND" "IP" "PORT"
  echo "--------------------------------------------------------------"
  local i=0
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-4s %-22s %-18s %-6s\n" "$i" "$key" "$ip" "$port"
  done < <(backend_lines)
  [[ "$i" -eq 0 ]] && echo -e "${YLW}No hay backends cargados.${NC}"
}

delete_backend_pick() {
  echo -e "${CYA}Eliminar backend${NC}\n"
  mapfile -t lines < <(backend_lines)
  [[ "${#lines[@]}" -gt 0 ]] || { echo -e "${YLW}No hay backends.${NC}"; return 0; }

  local i=0
  for line in "${lines[@]}"; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-3s) %-22s -> %s:%s\n" "$i" "$key" "$ip" "$port"
  done

  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return 0; }
  (( n>=1 && n<=${#lines[@]} )) || { echo -e "${RED}Fuera de rango.${NC}"; return 0; }

  target="${lines[$((n-1))]}"
  awk -v t="$target" '$0!=t{print}' "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" || true
  mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"

  rebuild_balancer_files
  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ Eliminado.${NC}"
}

# ------------------ HEALTHCHECK ------------------
healthcheck_all() {
  echo -e "${CYA}Healthcheck (HTTP y latencia)${NC}"
  echo -e "${DIM}HTTP 000 = no responde ‚Ä¢ timeout curl: ${CURL_TMO}s${NC}\n"
  printf "%-22s %-18s %-6s %-6s %-10s\n" "BACKEND" "IP" "PORT" "HTTP" "LAT(ms)"
  echo "------------------------------------------------------------------"
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    out="$(curl -m "$CURL_TMO" -s -o /dev/null -w "%{http_code} %{time_total}" "${url}/" || echo "000 9.999")"
    code="$(echo "$out" | awk '{print $1}')"
    t="$(echo "$out" | awk '{print $2}')"
    ms="$(awk -v x="$t" 'BEGIN{printf "%.0f", x*1000}')"
    printf "%-22s %-18s %-6s %-6s %-10s\n" "$key" "$ip" "$port" "$code" "$ms"
  done < <(backend_lines)
}

# ------------------ VALIDAR CONEXI√ìN ------------------
validate_connection_test() {
  echo -e "${CYA}Validar conexi√≥n (dominio ‚Üí backend por header)${NC}\n"
  pick_domain || return 0
  pick_backend || return 0

  echo
  echo -e "${WHT}Probando:${NC}"
  echo "  Dominio : ${PICKED_DOMAIN}"
  echo "  Header  : ${HEADER_NAME}: ${PICKED_BACKEND}"
  echo "  Backend : ${PICKED_BACKEND_URL}"
  echo

  echo -e "${DIM}1) Dominio responde:${NC}"
  curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" "http://${PICKED_DOMAIN}/" || true
  echo

  echo -e "${DIM}2) Dominio + header:${NC}"
  curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" -H "${HEADER_NAME}: ${PICKED_BACKEND}" "http://${PICKED_DOMAIN}/" || true
  echo

  echo -e "${DIM}3) Backend directo:${NC}"
  curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" "${PICKED_BACKEND_URL}/" || true
  echo
}

# ------------------ TR√ÅFICO (IP / BACKEND) ------------------
traffic_stats() {
  read_cfg
  echo -e "${CYA}Tr√°fico (por IP o Backend)${NC}"
  echo -e "${DIM}Lee ${STATS_LOG}. Muestra totales por √∫ltimas l√≠neas (si est√° vac√≠o, no hubo tr√°fico).${NC}\n"

  [[ -f "$STATS_LOG" ]] || { echo -e "${YLW}No existe todav√≠a: ${STATS_LOG}${NC}"; return 0; }
  local lines=5000
  read -r -p "Cantidad de l√≠neas a analizar (Enter=${lines}): " in
  lines="${in:-$lines}"

  echo
  echo "1) Por IP"
  echo "2) Por Backend (header)"
  read -r -p "Opci√≥n: " op

  case "$op" in
    1)
      echo
      printf "%-18s %-12s %-10s\n" "IP" "TOTAL(MB)" "REQ"
      echo "---------------------------------------------"
      tail -n "$lines" "$STATS_LOG" | awk -F'|' '
        {ip=$2; bytes=$7; req[ip]+=1; b[ip]+=bytes}
        END{
          for(i in b){
            mb=b[i]/1024/1024;
            printf "%-18s %-12.2f %-10d\n", i, mb, req[i]
          }
        }' | sort -k2 -nr | head -n 30
      ;;
    2)
      echo
      printf "%-22s %-12s %-10s\n" "BACKEND" "TOTAL(MB)" "REQ"
      echo "---------------------------------------------------"
      tail -n "$lines" "$STATS_LOG" | awk -F'|' '
        {be=$4; if(be=="") be="(vac√≠o)"; bytes=$7; req[be]+=1; b[be]+=bytes}
        END{
          for(i in b){
            mb=b[i]/1024/1024;
            printf "%-22s %-12.2f %-10d\n", i, mb, req[i]
          }
        }' | sort -k2 -nr | head -n 30
      ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ------------------ FIREWALL UFW (Opci√≥n 13) ------------------
ufw_open_port() {
  echo -e "${CYA}Firewall UFW: permitir tr√°fico por puerto${NC}"
  echo -e "${DIM}Ejemplo: 80/tcp (HTTP) o 443/tcp (HTTPS).${NC}\n"

  command -v ufw >/dev/null 2>&1 || { echo -e "${YLW}UFW no est√° instalado. Instalalo con: apt install -y ufw${NC}"; return 0; }

  ufw status || true
  echo

  read -r -p "Puerto a habilitar (ej: 80 o 443): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return 0; }

  ufw allow "${port}/tcp" || true
  [[ "$port" == "80" ]] && ufw allow 'Nginx HTTP' || true
  [[ "$port" == "443" ]] && ufw allow 'Nginx Full' || true
  ufw reload || true

  echo -e "${GRN}‚úÖ Regla aplicada.${NC}"
  ufw status || true
}

# ------------------ BACKUP / RESTORE ------------------
backup_bundle() {
  mkdir -p "$BACKUP_DIR"
  local out="${BACKUP_DIR}/bundle-$(date +%Y%m%d-%H%M%S).tar.gz"
  tar -czf "$out" \
    /etc/nginx/nginx.conf \
    /etc/nginx/conf.d/backendmgr \
    /etc/backendmgr \
    /var/lib/backendmgr 2>/dev/null || true
  echo -e "${GRN}‚úÖ Backup creado:${NC} $out"
}

restore_bundle() {
  echo -e "${CYA}Restaurar backup${NC}"
  ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | nl -w2 -s') ' || { echo "No hay backups."; return 0; }
  read -r -p "N√∫mero: " n
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | sed -n "${n}p")"
  [[ -n "${file:-}" ]] || { echo -e "${YLW}Selecci√≥n inv√°lida.${NC}"; return 0; }

  echo -e "${YLW}‚ö†Ô∏è Backup preventivo antes de restaurar...${NC}"
  backup_bundle
  tar -xzf "$file" -C / 2>/dev/null || true
  write_apply_conf
  rebuild_balancer_files
  nginx_test_reload
  echo -e "${GRN}‚úÖ Restaurado.${NC}"
}

# ------------------ Servicios Nginx juntos ------------------
nginx_services_menu() {
  echo -e "${CYA}Servicios Nginx${NC}"
  echo " 1) Status"
  echo " 2) Stop (detener)"
  echo " 3) Start (reanudar)"
  echo " 4) Reload (recargar config)"
  echo " 5) Restart (reiniciar)"
  echo " 0) Volver"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1) systemctl status nginx --no-pager || true ;;
    2) systemctl stop nginx || true; echo -e "${GRN}‚úÖ Stop OK.${NC}" ;;
    3) systemctl start nginx || true; echo -e "${GRN}‚úÖ Start OK.${NC}" ;;
    4) nginx_test_reload; echo -e "${GRN}‚úÖ Reload OK.${NC}" ;;
    5) systemctl restart nginx || true; echo -e "${GRN}‚úÖ Restart OK.${NC}" ;;
    0) return 0 ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ------------------ MENU ------------------
menu() {
  echo -e "${WHT}üìå MEN√ö PRINCIPAL${NC}"
  echo "  2) ‚ûï Agregar backend (nombre + IP + puerto)"
  echo "  3) üåê Agregar dominio madre (AUTO crea server)"
  echo "  4) üìÑ Listar backends (backend / IP / puerto)"
  echo "  5) üåç Listar dominios madre (servers)"
  echo "  6) üóëÔ∏è  Eliminar backend"
  echo "  7) ‚úÖ Healthcheck (HTTP y latencia)"
  echo "  8) üß™ Validar conexi√≥n (dominio ‚Üí backend por header)"
  echo "  9) üß© Editar timeouts del dominio madre (Enter=default 300/600/600)"
  echo " 10) ‚öñÔ∏è Balanceador (OFF/RANDOM/STICKY-IP)"
  echo " 11) üö¶ Limitar ancho de banda por IP o Backend (limit_rate)"
  echo " 12) üìä Tr√°fico por IP / Backend (stats log)"
  echo " 13) üî• Firewall UFW: abrir puerto (80/443/otro)"
  echo " 14) üíæ Backup"
  echo " 15) ‚ôªÔ∏è  Restaurar backup"
  echo " 16) ‚öôÔ∏è  Servicios de Nginx (Status/Stop/Start/Reload/Restart)"
  echo "  0) üö™ Salir"
  echo
}

main() {
  need_root
  ensure_jq
  ensure_cfg
  ensure_files
  read_cfg

  # asegurar que existan apply/balance (sin romper)
  write_apply_conf >/dev/null 2>&1 || true
  rebuild_balancer_files >/dev/null 2>&1 || true

  while true; do
    banner
    menu
    read -r -p "Opci√≥n: " opt
    echo
    case "$opt" in
      2) add_backend; pause ;;
      3) add_domain_auto_create; pause ;;
      4) list_backends; pause ;;
      5) list_domains; pause ;;
      6) delete_backend_pick; pause ;;
      7) healthcheck_all; pause ;;
      8) validate_connection_test; pause ;;
      9) create_or_edit_server_http; pause ;;
      10) set_balance_mode; pause ;;
      11) speed_limit_menu; pause ;;
      12) traffic_stats; pause ;;
      13) ufw_open_port; pause ;;
      14) backup_bundle; pause ;;
      15) restore_bundle; pause ;;
      16) nginx_services_menu; pause ;;
      0) exit 0 ;;
      *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}"; pause ;;
    esac
  done
}

main
