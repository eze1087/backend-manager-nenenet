#!/usr/bin/env bash
set -euo pipefail

APP_NAME="Backend Manager Nenenet 3.0"
APP_VER="3.0"

CFG_FILE="/etc/backendmgr/config.json"
BACKUP_DIR="/root/backendmgr-backups"

NGX_DIR="/etc/nginx/conf.d/backendmgr"
NGX_MAIN_INCLUDE="${NGX_DIR}/backendmgr.conf"
NGX_BACKENDS_MAP="${NGX_DIR}/backends.map"
NGX_DOMAINS_MAP="${NGX_DIR}/domains.map"
NGX_DEFAULTS_MAP="${NGX_DIR}/defaults.map"
NGX_LOGGING_SNIP="${NGX_DIR}/logging.conf"
NGX_APPLY_SNIP="${NGX_DIR}/apply.conf"

NGX_BALANCER_CONF="${NGX_DIR}/balancer.conf"
NGX_BALANCED_MAP="${NGX_DIR}/balanced.map"
NGX_LIMITS_IP="${NGX_DIR}/limits_ip.map"
NGX_LIMITS_BACKEND="${NGX_DIR}/limits_backend.map"
NGX_LIMITS_URL="${NGX_DIR}/limits_url.map"

NC='\033[0m'
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
CYA='\033[0;36m'
WHT='\033[1;37m'
DIM='\033[2m'

need_root() { [[ ${EUID:-999} -eq 0 ]] || { echo -e "${RED}ERROR:${NC} sudo nginx"; exit 1; }; }
die() { echo -e "${RED}ERROR:${NC} $*"; exit 1; }
pause() { echo; read -r -p "Enter para continuar..." _; }

read_cfg() {
  [[ -f "$CFG_FILE" ]] || die "Falta $CFG_FILE (instalÃ¡ con install.sh)."
  HEADER_NAME="$(jq -r '.header_name' "$CFG_FILE")"
  RL_ENABLED="$(jq -r '.rate_limit_enabled' "$CFG_FILE")"
  RL_RATE="$(jq -r '.rate_limit_rate' "$CFG_FILE")"
  RL_BURST="$(jq -r '.rate_limit_burst' "$CFG_FILE")"
  CONN_LIMIT="$(jq -r '.conn_limit' "$CFG_FILE")"
  CURL_TMO="$(jq -r '.curl_timeout_seconds' "$CFG_FILE")"
  WINDOW_SEC="$(jq -r '.traffic_window_seconds' "$CFG_FILE")"
  STATS_LOG="$(jq -r '.stats_log_path' "$CFG_FILE")"
  BAL_MODE="$(jq -r '.balance_mode' "$CFG_FILE")"
  BAL_CAP="$(jq -r '.balance_max_slots_cap' "$CFG_FILE")"
}

ensure_files() {
  for f in "$NGX_MAIN_INCLUDE" "$NGX_DOMAINS_MAP" "$NGX_DEFAULTS_MAP" "$NGX_LOGGING_SNIP" "$NGX_APPLY_SNIP" \
           "$NGX_BALANCER_CONF" "$NGX_BALANCED_MAP" "$NGX_BACKENDS_MAP" "$NGX_LIMITS_IP" "$NGX_LIMITS_BACKEND" "$NGX_LIMITS_URL"
  do
    [[ -f "$f" ]] || : > "$f"
  done
}

banner() {
  clear
  echo -e "${CYA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${CYA}â•‘${NC}  ðŸš€ ${APP_NAME}  v${APP_VER}                                   ${CYA}â•‘${NC}"
  echo -e "${CYA}â•‘${NC}  Header: ${WHT}${HEADER_NAME}${NC} | Balance: ${WHT}${BAL_MODE}${NC} | Limits: IP/Backend/URL   ${CYA}â•‘${NC}"
  echo -e "${CYA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo
}

nginx_active() { systemctl is-active --quiet nginx && echo "ACTIVO" || echo "INACTIVO"; }
nginx_test_reload() { nginx -t && systemctl reload nginx; }

backup_bundle() {
  mkdir -p "$BACKUP_DIR"
  local out="${BACKUP_DIR}/bundle-$(date +%Y%m%d-%H%M%S).tar.gz"
  tar -czf "$out" /etc/nginx /etc/backendmgr /var/lib/backendmgr 2>/dev/null || true
  echo -e "${GRN}âœ… Backup creado:${NC} $out"
}

restore_bundle() {
  echo -e "${CYA}Restaurar backup${NC}"
  ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | nl -w2 -s') ' || { echo "No hay backups."; return; }
  echo
  read -r -p "NÃºmero: " n
  local file
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | sed -n "${n}p")"
  [[ -n "${file:-}" ]] || { echo -e "${YLW}SelecciÃ³n invÃ¡lida.${NC}"; return; }

  echo -e "${YLW}âš ï¸ Backup de seguridad antes de restaurar.${NC}"
  backup_bundle
  tar -xzf "$file" -C / 2>/dev/null || true
  nginx_test_reload
  echo -e "${GRN}âœ… Restaurado.${NC}"
}

validate_domain() { [[ "$1" =~ ^[A-Za-z0-9.-]{3,253}$ ]]; }
validate_key() { [[ "$1" =~ ^[A-Za-z0-9_.:-]{2,64}$ ]]; }
validate_url() { [[ "$1" =~ ^http://[A-Za-z0-9._-]+:[0-9]{2,5}$ ]]; }
validate_ip() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }
validate_rate() { [[ "$1" == "0" || "$1" =~ ^[0-9]+[kKmM]$ ]]; }

# -------- Dominios / Backends (resumen) --------

list_domains() {
  echo -e "${WHT}Dominios:${NC}"
  grep -E '^\s*"[A-Za-z0-9.-]+"\s+"[A-Za-z0-9.-]+"\s*;' "$NGX_DOMAINS_MAP" \
    | sed -E 's/^\s*"([^"]+)".*$/\1/' | sort -u || true
}

add_domain() {
  echo -e "${CYA}Agregar dominio${NC}"
  read -r -p "Dominio: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return; }

  if ! grep -qE "^\s*\"${dom//\./\\.}\"" "$NGX_DOMAINS_MAP"; then
    awk -v dom="$dom" 'BEGIN{done=0} /^\}\s*$/ && !done{printf "    \"%s\" \"%s\";\n",dom,dom; done=1} {print}' \
      "$NGX_DOMAINS_MAP" > "${NGX_DOMAINS_MAP}.tmp" && mv "${NGX_DOMAINS_MAP}.tmp" "$NGX_DOMAINS_MAP"
  fi

  if ! grep -qE "^\s*\"${dom//\./\\.}\"" "$NGX_DEFAULTS_MAP"; then
    awk -v dom="$dom" 'BEGIN{done=0} /^\}\s*$/ && !done{printf "    \"%s\" \"http://127.0.0.1:8880\";\n",dom; done=1} {print}' \
      "$NGX_DEFAULTS_MAP" > "${NGX_DEFAULTS_MAP}.tmp" && mv "${NGX_DEFAULTS_MAP}.tmp" "$NGX_DEFAULTS_MAP"
  fi

  nginx_test_reload
  echo -e "${GRN}âœ… OK.${NC}"
}

list_backends_for_domain() {
  read -r -p "Dominio: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return; }

  echo -e "${WHT}Backends de ${dom}:${NC}"
  printf "%-22s %-38s\n" "KEY" "URL"
  echo "---------------------------------------------------------------"
  grep -E "^\s*\"${dom//\./\\.}:" "$NGX_BACKENDS_MAP" \
    | sed -E "s/^\s*\"${dom//\./\\.}:(.+)\"\s+\"(.+)\";.*/\1\t\2/" \
    | awk -F'\t' '{ printf "%-22s %-38s\n", $1, $2 }' || true
}

add_or_update_backend() {
  echo -e "${CYA}Agregar / Actualizar backend${NC}"
  read -r -p "Dominio: " dom
  read -r -p "Key: " key
  read -r -p "URL (http://IP:PUERTO): " url

  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return; }
  validate_key "$key" || { echo -e "${RED}Key invÃ¡lida.${NC}"; return; }
  validate_url "$url" || { echo -e "${RED}URL invÃ¡lida.${NC}"; return; }

  local dk="${dom}:${key}"
  if grep -qE "^\s*\"${dk//\./\\.}\"" "$NGX_BACKENDS_MAP"; then
    awk -v dk="$dk" -v url="$url" '{ re="^[ \t]*\""dk"\""; if($0 ~ re){ sub(/"http:\/\/[^"]+"/, "\""url"\"") } print }' \
      "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
  else
    printf "    \"%s\" \"%s\";\n" "$dk" "$url" >> "$NGX_BACKENDS_MAP"
  fi

  rebuild_balancer_files >/dev/null 2>&1 || true
  nginx_test_reload
  echo -e "${GRN}âœ… Guardado.${NC}"
}

delete_backend() {
  echo -e "${CYA}Eliminar backend${NC}"
  read -r -p "Dominio: " dom
  read -r -p "Key: " key
  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return; }
  validate_key "$key" || { echo -e "${RED}Key invÃ¡lida.${NC}"; return; }

  local dk="${dom}:${key}"
  grep -vE "^\s*\"${dk//\./\\.}\"" "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"

  rebuild_balancer_files >/dev/null 2>&1 || true
  nginx_test_reload
  echo -e "${GRN}âœ… Eliminado.${NC}"
}

# ---------------- HEALTHCHECK ----------------

healthcheck_all() {
  echo -e "${CYA}Healthcheck (todos)${NC}"
  echo -e "${DIM}curl timeout: ${CURL_TMO}s${NC}"
  echo
  printf "%-22s %-18s %-26s %-8s %-10s\n" "DOMINIO" "KEY" "URL" "HTTP" "LAT(ms)"
  echo "-------------------------------------------------------------------------------------"

  grep -E '^\s*"[A-Za-z0-9.-]+:[A-Za-z0-9_.:-]+"\s+"http://' "$NGX_BACKENDS_MAP" 2>/dev/null | while read -r line; do
    domkey="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    dom="${domkey%%:*}"
    key="${domkey#*:}"

    out="$(curl -m "$CURL_TMO" -s -o /dev/null -w "%{http_code} %{time_total}" "${url}/" || echo "000 9.999")"
    code="$(echo "$out" | awk '{print $1}')"
    t="$(echo "$out" | awk '{print $2}')"
    ms="$(awk -v x="$t" 'BEGIN{printf "%.0f", x*1000}')"

    printf "%-22s %-18s %-26s %-8s %-10s\n" "$dom" "$key" "$url" "$code" "$ms"
  done
}

# ==========================
# âš–ï¸ BALANCEADOR
# ==========================
# Genera:
# - balancer.conf
# - balanced.map  (dom:slot -> url)
# Slots globales = max backends por dominio (cap)
# Mode:
#  - off: backendmgr_balance=0
#  - random: split_clients on "$remote_addr$msec$connection"
#  - iphash: split_clients on "$remote_addr"
# ==========================

get_domains_list() {
  grep -E '^\s*"[A-Za-z0-9.-]+"\s+"' "$NGX_DOMAINS_MAP" 2>/dev/null | sed -E 's/^\s*"([^"]+)".*$/\1/' | sort -u
}

count_backends_for_domain() {
  local dom="$1"
  grep -cE "^\s*\"${dom//\./\\.}:" "$NGX_BACKENDS_MAP" 2>/dev/null || echo 0
}

rebuild_balancer_files() {
  read_cfg

  local max=0 d c cap
  cap="$BAL_CAP"
  [[ "$cap" =~ ^[0-9]+$ ]] || cap=64

  while read -r d; do
    [[ -z "$d" ]] && continue
    c="$(count_backends_for_domain "$d")"
    (( c > max )) && max="$c"
  done < <(get_domains_list)

  (( max < 2 )) && max=2
  (( max > cap )) && max="$cap"

  # porcentajes enteros que sumen 100
  local base=$((100 / max))
  local rem=$((100 - base * max))

  # construir split_clients
  local split_key
  case "$BAL_MODE" in
    iphash) split_key="\$remote_addr" ;;
    random) split_key="\$remote_addr\$msec\$connection" ;;
    off|*) split_key="\$remote_addr" ;;
  esac

  # balanced.map: dom:i -> url (en orden)
  : > "$NGX_BALANCED_MAP"
  while read -r d; do
    [[ -z "$d" ]] && continue
    # lista URLs en orden
    mapfile -t urls < <(grep -E "^\s*\"${d//\./\\.}:" "$NGX_BACKENDS_MAP" \
      | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')
    local i=0
    for u in "${urls[@]}"; do
      [[ $i -ge $max ]] && break
      printf "    \"%s:%s\" \"%s\";\n" "$d" "$i" "$u" >> "$NGX_BALANCED_MAP"
      i=$((i+1))
    done
  done < <(get_domains_list)

  # balancer.conf
  if [[ "$BAL_MODE" == "off" ]]; then
    cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (balance OFF)
map $host $backendmgr_balance { default 0; }
set $backendmgr_slot "0";
map "$backend_domain:$backendmgr_slot" $balanced_backend_url { default $default_backend_url; }
EOF
  else
    {
      echo "# backendmgr balancer.conf (balance: ${BAL_MODE})"
      echo "map \$host \$backendmgr_balance { default 1; }"
      echo "split_clients \"${split_key}\" \$backendmgr_slot {"
      for ((i=0;i<max;i++)); do
        pct="$base"
        if (( rem > 0 )); then pct=$((pct+1)); rem=$((rem-1)); fi
        echo "    ${pct}% \"${i}\";"
      done
      echo "}"
      echo "map \"\$backend_domain:\$backendmgr_slot\" \$balanced_backend_url {"
      echo "    default \$default_backend_url;"
      echo "    include ${NGX_BALANCED_MAP};"
      echo "}"
    } > "$NGX_BALANCER_CONF"
  fi
}

set_balance_mode() {
  echo -e "${CYA}Balanceador (equilibrar trÃ¡fico)${NC}"
  echo "1) OFF (por header Backend)"
  echo "2) RANDOM (reparte por request)"
  echo "3) STICKY-IP (estable por IP)"
  echo
  read -r -p "OpciÃ³n: " op
  case "$op" in
    1) BAL_MODE="off" ;;
    2) BAL_MODE="random" ;;
    3) BAL_MODE="iphash" ;;
    *) echo "InvÃ¡lida"; return ;;
  esac

  jq --arg v "$BAL_MODE" '.balance_mode = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
  rebuild_balancer_files
  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}âœ… Balance: ${BAL_MODE}${NC}"
}

# ==========================
# ðŸš¦ LIMITAR VELOCIDAD
# ==========================

write_apply_conf() {
  read_cfg
  # Aplica stats + balance + limit_rate en location /
  cat > "$NGX_APPLY_SNIP" <<EOF
# ${APP_NAME} apply.conf
# Incluir dentro de location / :
# include /etc/nginx/conf.d/backendmgr/apply.conf;

# Stats log
access_log ${STATS_LOG} backendmgr_stats;

# Balance: si estÃ¡ activo, pisa \$backend_url al valor balanceado
if (\$backendmgr_balance = 1) {
    set \$backend_url \$balanced_backend_url;
}

# Rate limit (req/conn) si estÃ¡ activo
EOF

  if [[ "$RL_ENABLED" == "true" ]]; then
    cat >> "$NGX_APPLY_SNIP" <<EOF
limit_req zone=backendmgr_req burst=${RL_BURST} nodelay;
limit_conn backendmgr_conn ${CONN_LIMIT};
EOF
  else
    cat >> "$NGX_APPLY_SNIP" <<'EOF'
# rate-limit desactivado
EOF
  fi

  cat >> "$NGX_APPLY_SNIP" <<'EOF'

# Speed limit por IP/Backend/URL
# prioridad: Backend(dom:key) > URL(actual) > IP
set $nenenet_rate 0;

if ($backend_limit_rate != 0) { set $nenenet_rate $backend_limit_rate; }
if ($nenenet_rate = 0) { if ($url_limit_rate_
