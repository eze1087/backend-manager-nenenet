#!/usr/bin/env bash
set -Eeuo pipefail

APP_NAME="Backend Manager Nenenet 3.0"
APP_VER="4.83"

# ------------------ RUTAS ------------------
CFG_DIR="/etc/backendmgr"
CFG_FILE="${CFG_DIR}/config.json"

NGX_DIR="/etc/nginx/conf.d/backendmgr"
SERVERS_DIR="${NGX_DIR}/servers"

NGX_BACKENDS_MAP="${NGX_DIR}/backends.map"
NGX_APPLY_SNIP="${NGX_DIR}/apply.conf"
NGX_MAIN_INCLUDE="${NGX_DIR}/backendmgr.conf"

# Balance (viejo: se deja OFF para no romper compatibilidad)
NGX_BALANCER_CONF="${NGX_DIR}/balancer.conf"
NGX_BALANCED_MAP="${NGX_DIR}/balanced.map"

# Mothers (nuevo balance por dominio madre / pool VPS)
NGX_MOTHERS_DIR="${NGX_DIR}/mothers"
NGX_MOTHERS_UPSTREAMS="${NGX_DIR}/mothers_upstreams.conf"

# Targets (proxy_pass por dominio)
NGX_TARGETS_DIR="${NGX_DIR}/targets"

# Speed limits
NGX_LIMITS_IP="${NGX_DIR}/limits_ip.map"
NGX_LIMITS_BACKEND="${NGX_DIR}/limits_backend.map"
NGX_LIMITS_URL="${NGX_DIR}/limits_url.map"

# Logging snippet
NGX_LOGGING_SNIP="${NGX_DIR}/logging.conf"

# backups en /etc/nginx (misma ubicaci√≥n)
BACKUP_DIR="/etc/nginx/backendmgr-backups"

# Logs
PANEL_LOG="/var/log/backendmgr.panel.log"

# ------------------ COLORES ------------------
NC='\033[0m'
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
CYA='\033[0;36m'
WHT='\033[1;37m'
DIM='\033[2m'

# ------------------ TTY + TRAPS ------------------
mkdir -p /var/log 2>/dev/null || true

# Forzar TTY para que SIEMPRE se vea el men√∫ al llamar con nginx
if [[ -r /dev/tty && -w /dev/tty ]]; then
  exec </dev/tty >/dev/tty 2>&1
fi

on_err() {
  local rc=$?
  echo "‚ùå ERROR: backendmgr rc=${rc} | l√≠nea ${LINENO} | cmd: ${BASH_COMMAND}" | tee -a "$PANEL_LOG" >/dev/null
  echo -e "${YLW}üìå Log:${NC} ${PANEL_LOG}"
  exit "$rc"
}
trap on_err ERR

# Debug opcional:
# BACKENDMGR_DEBUG=1 nginx
if [[ "${BACKENDMGR_DEBUG:-0}" == "1" ]]; then
  exec 3>>"$PANEL_LOG"
  BASH_XTRACEFD=3
  set -x
fi

# ------------------ HELPERS ------------------
need_root() { [[ ${EUID:-999} -eq 0 ]] || { echo -e "${RED}ERROR:${NC} ejecut√°: sudo nginx"; exit 1; }; }
pause() { echo; read -r -p "Enter para volver..." _; }

ensure_jq() {
  if command -v jq >/dev/null 2>&1; then return 0; fi
  echo -e "${YLW}‚ö†Ô∏è Falta jq.${NC} Intento instalarlo..."
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y >/dev/null 2>&1 || true
  apt-get install -y jq >/dev/null 2>&1 || true
  command -v jq >/dev/null 2>&1 || { echo -e "${RED}ERROR:${NC} no pude instalar jq. Hac√©: apt install -y jq"; exit 1; }
}

write_default_cfg() {
  mkdir -p "$CFG_DIR"
  cat > "$CFG_FILE" <<'JSON'
{
  "header_name": "Backend",
  "primary_domain": "",
  "rate_limit_enabled": true,
  "rate_limit_rate": "10r/s",
  "rate_limit_burst": 20,
  "conn_limit": 30,
  "curl_timeout_seconds": 8,
  "traffic_window_seconds": 60,
  "stats_log_path": "/var/log/nginx/backendmgr.stats.log",

  "traffic_stats_enabled": true,
  "traffic_stats_since": "",

  "balance_mode": "off",
  "balance_max_slots_cap": 64
}
JSON
}

ensure_cfg() {
  [[ -f "$CFG_FILE" ]] || write_default_cfg
  # asegurar keys en configs viejos
  local tmp
  tmp="$(mktemp)"

  jq '
    .balance_max_slots_cap = (.balance_max_slots_cap // 64)
    | .traffic_stats_enabled = (.traffic_stats_enabled // true)
    | .traffic_stats_since = (.traffic_stats_since // "")
  ' "$CFG_FILE" > "$tmp" 2>/dev/null || { rm -f "$tmp"; return 0; }

  mv "$tmp" "$CFG_FILE"
}

ensure_files() {
  mkdir -p \
    "$NGX_DIR" "$SERVERS_DIR" \
    "$NGX_MOTHERS_DIR" "$NGX_TARGETS_DIR" \
    "$BACKUP_DIR" /var/log/nginx /var/lib/backendmgr
  chmod 700 "$BACKUP_DIR" || true

  [[ -f "$NGX_BACKENDS_MAP" ]] || : > "$NGX_BACKENDS_MAP"
  [[ -f "$NGX_APPLY_SNIP" ]] || : > "$NGX_APPLY_SNIP"
  [[ -f "$NGX_BALANCER_CONF" ]] || : > "$NGX_BALANCER_CONF"
  [[ -f "$NGX_BALANCED_MAP" ]] || : > "$NGX_BALANCED_MAP"

  [[ -f "$NGX_LIMITS_IP" ]] || : > "$NGX_LIMITS_IP"
  [[ -f "$NGX_LIMITS_BACKEND" ]] || : > "$NGX_LIMITS_BACKEND"
  [[ -f "$NGX_LIMITS_URL" ]] || : > "$NGX_LIMITS_URL"

  [[ -f "$NGX_MOTHERS_UPSTREAMS" ]] || : > "$NGX_MOTHERS_UPSTREAMS"

  [[ -f "$NGX_LOGGING_SNIP" ]] || cat > "$NGX_LOGGING_SNIP" <<'EOF'
log_format backendmgr_stats '$time_local|$remote_addr|$host|$http_backend|$upstream_addr|$status|$body_bytes_sent|$request_time|$upstream_response_time|$request';
EOF
}

read_cfg() {
  [[ -f "$CFG_FILE" ]] || { echo -e "${RED}Falta ${CFG_FILE}. Reinstal√° con install.sh${NC}"; exit 1; }

  HEADER_NAME="$(jq -r '.header_name // "Backend"' "$CFG_FILE" 2>/dev/null || echo "Backend")"
  PRIMARY_DOMAIN="$(jq -r '.primary_domain // ""' "$CFG_FILE" 2>/dev/null || echo "")"
  [[ "$PRIMARY_DOMAIN" == "null" ]] && PRIMARY_DOMAIN=""

  RL_ENABLED="$(jq -r '.rate_limit_enabled // true' "$CFG_FILE" 2>/dev/null || echo "true")"
  RL_RATE="$(jq -r '.rate_limit_rate // "10r/s"' "$CFG_FILE" 2>/dev/null || echo "10r/s")"
  RL_BURST="$(jq -r '.rate_limit_burst // 20' "$CFG_FILE" 2>/dev/null || echo "20")"
  CONN_LIMIT="$(jq -r '.conn_limit // 30' "$CFG_FILE" 2>/dev/null || echo "30")"

  CURL_TMO="$(jq -r '.curl_timeout_seconds // 8' "$CFG_FILE" 2>/dev/null || echo "8")"
  WINDOW_SEC="$(jq -r '.traffic_window_seconds // 60' "$CFG_FILE" 2>/dev/null || echo "60")"
  STATS_LOG="$(jq -r '.stats_log_path // "/var/log/nginx/backendmgr.stats.log"' "$CFG_FILE" 2>/dev/null || echo "/var/log/nginx/backendmgr.stats.log")"

  # ‚úÖ NUEVO (para opci√≥n 11)
  TRAFFIC_STATS_ENABLED="$(jq -r '.traffic_stats_enabled // true' "$CFG_FILE" 2>/dev/null || echo "true")"
  TRAFFIC_STATS_SINCE="$(jq -r '.traffic_stats_since // ""' "$CFG_FILE" 2>/dev/null || echo "")"
  [[ "$TRAFFIC_STATS_SINCE" == "null" ]] && TRAFFIC_STATS_SINCE=""

  BAL_MODE="$(jq -r '.balance_mode // "off"' "$CFG_FILE" 2>/dev/null || echo "off")"

  BAL_CAP="$(jq -r '.balance_max_slots_cap // 64' "$CFG_FILE" 2>/dev/null || echo 64)"
  [[ -z "${BAL_CAP:-}" || "$BAL_CAP" == "null" ]] && BAL_CAP="64"
  [[ "$BAL_CAP" =~ ^[0-9]+$ ]] || BAL_CAP="64"
}

# ---------- Helpers banner ----------
nginx_state() {
  if command -v systemctl >/dev/null 2>&1; then
    if systemctl is-active --quiet nginx; then echo "ON"; else echo "OFF"; fi
  else
    if pidof nginx >/dev/null 2>&1; then echo "ON"; else echo "OFF"; fi
  fi
}

backend_lines() { grep -E '^\s*"[A-Za-z0-9_.:-]+"\s+"http://' "$NGX_BACKENDS_MAP" 2>/dev/null || true; }
server_files() { ls -1 "${SERVERS_DIR}"/*.conf 2>/dev/null || true; }

backend_count() { backend_lines | wc -l | tr -d ' '; }
domain_count() { server_files | wc -l | tr -d ' '; }

primary_domain_active() {
  if [[ -n "${PRIMARY_DOMAIN:-}" && "${PRIMARY_DOMAIN}" != "null" ]]; then
    echo "$PRIMARY_DOMAIN"; return 0
  fi

  local f dom
  f="$(server_files | head -n1 || true)"
  if [[ -n "$f" && -f "$f" ]]; then
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
    [[ -n "${dom:-}" ]] && { echo "$dom"; return 0; }
  fi

  echo "(no configurado)"
}

last_backup_info() {
  local file
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | head -n1 || true)"
  if [[ -z "$file" ]]; then
    echo "NO"; return 0
  fi

  local dt
  dt="$(basename "$file" | sed -nE 's/^bundle-([0-9]{8})-([0-9]{6})\.tar\.gz$/\1 \2/p')"
  if [[ -n "$dt" ]]; then
    local d t
    d="${dt%% *}"; t="${dt##* }"
    echo "SI (${d:0:4}-${d:4:2}-${d:6:2} ${t:0:2}:${t:2:2}:${t:4:2})"
  else
    echo "SI ($(date -r "$file" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "fecha desconocida"))"
  fi
}

# imprime una l√≠nea dentro del recuadro con ancho fijo, sin que se rompa
box_line() {
  local w="${1:-62}"
  shift || true
  local text="$*"
  if [[ ${#text} -gt $w ]]; then
    text="${text:0:$w}"
  fi
  printf "‚ïë %-*s ‚ïë\n" "$w" "$text"
}

nginx_test_reload() {
  if ! command -v nginx >/dev/null 2>&1; then
    echo -e "${YLW}‚ö†Ô∏è nginx no est√° instalado.${NC}"
    return 0
  fi
  if ! timeout 10s nginx -t; then
    echo -e "${YLW}‚ö†Ô∏è nginx -t fall√≥. No recargo.${NC}"
    return 0
  fi
  timeout 8s nginx -s reload >/dev/null 2>&1 || true
  return 0
}

# ‚úÖ Banner con ancho autom√°tico (para que el recuadro ‚Äúquede bien‚Äù siempre)
banner() {
  clear || true
  read_cfg 2>/dev/null || true

  local ng_state dom_active bcount dcount bkp
  ng_state="$(nginx_state)"
  dom_active="$(primary_domain_active)"
  bcount="$(backend_count)"
  dcount="$(domain_count)"
  bkp="$(last_backup_info)"

  local l1 l2 l3 l4 l5 l6
  l1="üöÄ ${APP_NAME} v${APP_VER}"
  l2="Nginx: ${ng_state} | Dominios: ${dcount} | Backends: ${bcount}"
  l3="Dominio madre activo: ${dom_active}"
  l4="Header: ${HEADER_NAME} | Balance: ${BAL_MODE} (cap ${BAL_CAP})"
  l5="Stats: ${STATS_LOG}"
  l6="Backup: ${bkp}"

  local W=62
  local n
  for n in "${#l1}" "${#l2}" "${#l3}" "${#l4}" "${#l5}" "${#l6}"; do
    (( n > W )) && W="$n"
  done
  (( W < 62 )) && W=62
  (( W > 90 )) && W=90

  echo -e "${CYA}‚ïî$(printf '‚ïê%.0s' $(seq 1 $((W+2))))‚ïó${NC}"
  box_line "$W" "$l1"
  box_line "$W" "$l2"
  box_line "$W" "$l3"
  box_line "$W" "$l4"
  box_line "$W" "$l5"
  box_line "$W" "$l6"
  echo -e "${CYA}‚ïö$(printf '‚ïê%.0s' $(seq 1 $((W+2))))‚ïù${NC}"
  echo
}

validate_domain() { [[ "$1" =~ ^[A-Za-z0-9.-]{3,253}$ ]]; }
validate_key() { [[ "$1" =~ ^[A-Za-z0-9_.:-]{2,64}$ ]]; }
validate_ip() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }
validate_rate() { [[ "$1" == "0" || "$1" =~ ^[0-9]+[kKmM]$ ]]; }

# ------------------ BALANCER LEGACY (se deja OFF) ------------------
# (Solo para que no falle nada que lo llame; tu balance real est√° en "mothers_menu")
rebuild_balancer_files() {
  cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (legacy balance OFF)
map $host $backendmgr_balance { default 0; }
map $host $backendmgr_slot { default "0"; }

map $backendmgr_slot $balanced_backend_url {
    default $backend_url;
    include /etc/nginx/conf.d/backendmgr/balanced.map;
}
EOF
  : > "$NGX_BALANCED_MAP" 2>/dev/null || true
  return 0
}

# ------------------ http{} include (nenenet_backend_url + nenenet_rate) ------------------
ensure_http_conf_maps() {
  [[ -f "$NGX_MAIN_INCLUDE" ]] || return 0
  if grep -q 'nenenet_backend_url' "$NGX_MAIN_INCLUDE" && grep -q 'nenenet_rate' "$NGX_MAIN_INCLUDE"; then
    return 0
  fi

  cat > "$NGX_MAIN_INCLUDE" <<EOF
# ${APP_NAME} (http{})
include ${NGX_LOGGING_SNIP};

limit_req_zone \$binary_remote_addr zone=backendmgr_req:10m rate=10r/s;
limit_conn_zone \$binary_remote_addr zone=backendmgr_conn:10m;

include ${NGX_BALANCER_CONF};

map \$remote_addr \$ip_limit_rate { default 0; include ${NGX_LIMITS_IP}; }
map \$http_backend \$backend_limit_rate { default 0; include ${NGX_LIMITS_BACKEND}; }
map \$backend_url \$url_limit_rate { default 0; include ${NGX_LIMITS_URL}; }

map \$backend_limit_rate \$nenenet_rate_step1 {
  default \$backend_limit_rate;
  0 \$url_limit_rate;
}
map \$nenenet_rate_step1 \$nenenet_rate {
  default \$nenenet_rate_step1;
  0 \$ip_limit_rate;
}

map \$backendmgr_balance \$nenenet_backend_url {
  0 \$backend_url;
  1 \$balanced_backend_url;
}

include ${SERVERS_DIR}/*.conf;
EOF
}

# ------------------ APPLY.CONF ------------------
write_apply_conf() {
  read_cfg

  cat > "$NGX_APPLY_SNIP" <<EOF
# ${APP_NAME} apply.conf
EOF

  # ‚úÖ NUEVO: activar/desactivar logging de tr√°fico (opci√≥n 11)
  if [[ "${TRAFFIC_STATS_ENABLED}" == "true" ]]; then
    cat >> "$NGX_APPLY_SNIP" <<EOF
access_log ${STATS_LOG} backendmgr_stats;
EOF
  else
    cat >> "$NGX_APPLY_SNIP" <<'EOF'
access_log off;
EOF
  fi

  cat >> "$NGX_APPLY_SNIP" <<EOF

EOF

  if [[ "$RL_ENABLED" == "true" ]]; then
    cat >> "$NGX_APPLY_SNIP" <<EOF
limit_req zone=backendmgr_req burst=${RL_BURST} nodelay;
limit_conn backendmgr_conn ${CONN_LIMIT};

EOF
  else
    cat >> "$NGX_APPLY_SNIP" <<'EOF'
# rate-limit desactivado
EOF
  fi

  cat >> "$NGX_APPLY_SNIP" <<'EOF'

# Speed limits (0 = unlimited) calculado en http{} por maps
limit_rate $nenenet_rate;
EOF
}

# ‚úÖ NUEVO: toggles para opci√≥n 11 (sin tocar tus otras opciones)
set_traffic_stats_enabled() {
  local new="$1" # true/false
  local since=""
  if [[ "$new" == "true" ]]; then
    since="$(date '+%Y-%m-%d %H:%M:%S')"
  fi

  jq --argjson en "$new" --arg since "$since" '
    .traffic_stats_enabled = $en
    | .traffic_stats_since = $since
  ' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"

  read_cfg
  write_apply_conf
  nginx_test_reload
  return 0
}

# ------------------ MOTHERS BALANCE (por dominio madre) ------------------
mother_safe() { echo "$1" | sed 's/[^A-Za-z0-9_]/_/g'; }
mother_list_file() { echo "${NGX_MOTHERS_DIR}/$1.list"; }
mother_mode_file() { echo "${NGX_MOTHERS_DIR}/$1.mode"; }
mother_upstream_name() { echo "backendmgr_mothers_$(mother_safe "$1")"; }
target_file() { echo "${NGX_TARGETS_DIR}/$1.conf"; }

ensure_domain_target_exists() {
  local dom="$1"
  mkdir -p "$NGX_TARGETS_DIR"
  if [[ ! -f "$(target_file "$dom")" ]]; then
    cat > "$(target_file "$dom")" <<EOF
# target default: backend directo (por header -> map)
proxy_pass \$nenenet_backend_url;
EOF
  fi
}

mothers_enable_for_domain() {
  local dom="$1"
  ensure_domain_target_exists "$dom"
  local up; up="$(mother_upstream_name "$dom")"

  cat > "$(target_file "$dom")" <<EOF
# target: balanceo entre madres (upstream)
proxy_pass http://${up};
EOF
}

mothers_disable_for_domain() {
  local dom="$1"
  ensure_domain_target_exists "$dom"
  cat > "$(target_file "$dom")" <<EOF
# target: backend directo (por header -> map)
proxy_pass \$nenenet_backend_url;
EOF
}

rebuild_mothers_upstreams() {
  : > "$NGX_MOTHERS_UPSTREAMS"
  echo "# ${APP_NAME} mothers upstreams (http{})" >> "$NGX_MOTHERS_UPSTREAMS"

  local f dom mode up
  for f in "${NGX_MOTHERS_DIR}"/*.list; do
    [[ -f "$f" ]] || continue
    dom="$(basename "$f" .list)"
    up="$(mother_upstream_name "$dom")"

    mode="round_robin"
    [[ -f "$(mother_mode_file "$dom")" ]] && mode="$(cat "$(mother_mode_file "$dom")" 2>/dev/null || echo round_robin)"

    echo "" >> "$NGX_MOTHERS_UPSTREAMS"
    echo "upstream ${up} {" >> "$NGX_MOTHERS_UPSTREAMS"

    case "$mode" in
      least_conn) echo "    least_conn;" >> "$NGX_MOTHERS_UPSTREAMS" ;;
      ip_hash)    echo "    ip_hash;" >> "$NGX_MOTHERS_UPSTREAMS" ;;
      failover)   : ;;
      round_robin|*) : ;;
    esac

    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      if echo "$line" | grep -qE '^[0-9.]+:[0-9]+( +backup)?$'; then
        echo "    server ${line} max_fails=3 fail_timeout=5s;" >> "$NGX_MOTHERS_UPSTREAMS"
      fi
    done < "$f"

    echo "    keepalive 64;" >> "$NGX_MOTHERS_UPSTREAMS"
    echo "}" >> "$NGX_MOTHERS_UPSTREAMS"
  done

  ensure_mothers_include
  nginx_test_reload
}

# ‚úÖ Solo agrega el include de mothers upstreams (sin pisar backendmgr.conf)
ensure_mothers_include() {
  [[ -f "$NGX_MAIN_INCLUDE" ]] || return 0
  if ! grep -qF "$NGX_MOTHERS_UPSTREAMS" "$NGX_MAIN_INCLUDE" 2>/dev/null; then
    echo "" >> "$NGX_MAIN_INCLUDE"
    echo "include ${NGX_MOTHERS_UPSTREAMS};" >> "$NGX_MAIN_INCLUDE"
  fi
}

mothers_list() {
  local dom="$1"
  local lf; lf="$(mother_list_file "$dom")"
  [[ -f "$lf" ]] || { echo -e "${YLW}No hay madres cargadas para ${dom}.${NC}"; return 0; }

  echo -e "${CYA}Madres para:${NC} ${dom}"
  nl -w2 -s') ' "$lf" 2>/dev/null || true
}

mothers_add() {
  pick_domain_for_manage || return 0
  local dom="$PICKED_DOMAIN"
  local lf; lf="$(mother_list_file "$dom")"
  mkdir -p "$NGX_MOTHERS_DIR"
  [[ -f "$lf" ]] || : > "$lf"

  echo -e "${CYA}Agregar madre al pool de:${NC} ${dom}"
  echo -e "${DIM}Formato: IP y puerto (ej 10.0.0.2 : 80).${NC}\n"
  read -r -p "IP de la madre: " ip
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return 0; }
  read -r -p "Puerto (ej 80): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return 0; }

  local entry="${ip}:${port}"

  if grep -qxF "$entry" "$lf" 2>/dev/null; then
    echo -e "${YLW}Ya existe:${NC} $entry"
    return 0
  fi

  echo "$entry" >> "$lf"
  rebuild_mothers_upstreams
  echo -e "${GRN}‚úÖ Madre agregada:${NC} $entry"
}

mothers_remove() {
  pick_domain_for_manage || return 0
  local dom="$PICKED_DOMAIN"
  local lf; lf="$(mother_list_file "$dom")"
  [[ -f "$lf" ]] || { echo -e "${YLW}No hay madres para ${dom}.${NC}"; return 0; }

  echo -e "${CYA}Quitar madre de:${NC} ${dom}\n"
  nl -w2 -s') ' "$lf"
  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return 0; }

  local line
  line="$(sed -n "${n}p" "$lf" 2>/dev/null || true)"
  [[ -n "$line" ]] || { echo -e "${RED}Fuera de rango.${NC}"; return 0; }

  awk -v rm="$line" '$0!=rm{print}' "$lf" > "${lf}.tmp" && mv "${lf}.tmp" "$lf"
  rebuild_mothers_upstreams
  echo -e "${GRN}‚úÖ Madre eliminada:${NC} $line"
}

mothers_set_mode() {
  pick_domain_for_manage || return 0
  local dom="$PICKED_DOMAIN"
  mkdir -p "$NGX_MOTHERS_DIR"

  echo -e "${CYA}Modo de balance entre madres para:${NC} ${dom}"
  echo "1) round_robin (reparte)"
  echo "2) least_conn (menos conexiones)"
  echo "3) ip_hash (sticky por IP)"
  echo "4) failover (primario/secundario)"
  read -r -p "Opci√≥n: " op

  local mode="round_robin"
  case "$op" in
    1) mode="round_robin" ;;
    2) mode="least_conn" ;;
    3) mode="ip_hash" ;;
    4) mode="failover" ;;
    *) echo -e "${YLW}Inv√°lido.${NC}"; return 0 ;;
  esac

  echo "$mode" > "$(mother_mode_file "$dom")"

  local lf; lf="$(mother_list_file "$dom")"
  [[ -f "$lf" ]] || : > "$lf"

  if [[ "$mode" == "failover" ]]; then
    awk 'NR==1{print $0; next} {print $0 " backup"}' "$lf" | sed 's/ backup backup$/ backup/' > "${lf}.tmp" && mv "${lf}.tmp" "$lf"
  else
    sed 's/ *backup$//' "$lf" > "${lf}.tmp" && mv "${lf}.tmp" "$lf"
  fi

  rebuild_mothers_upstreams
  echo -e "${GRN}‚úÖ Modo guardado:${NC} $mode"
}

mothers_enable_disable() {
  pick_domain_for_manage || return 0
  local dom="$PICKED_DOMAIN"
  ensure_domain_target_exists "$dom"

  echo -e "${CYA}Balanceo entre madres para:${NC} ${dom}\n"
  echo "1) Activar (proxy_pass -> upstream mothers)"
  echo "2) Desactivar (proxy_pass -> backend directo por header)"
  read -r -p "Opci√≥n: " op

  case "$op" in
    1)
      mothers_enable_for_domain "$dom"
      rebuild_mothers_upstreams
      nginx_test_reload
      echo -e "${GRN}‚úÖ Activado.${NC}"
      ;;
    2)
      mothers_disable_for_domain "$dom"
      nginx_test_reload
      echo -e "${GRN}‚úÖ Desactivado.${NC}"
      ;;
    *) echo -e "${YLW}Inv√°lido.${NC}" ;;
  esac
}

mothers_menu() {
  echo -e "${CYA}‚öñÔ∏è Balanceo de Madres (Pool por dominio)${NC}"
  echo -e "${DIM}Reparte requests entre SERVIDORES MADRE (VPS) que tienen el mismo map backend‚ÜíIP.${NC}\n"
  echo "1) Ver madres de un dominio"
  echo "2) Agregar madre a un dominio"
  echo "3) Quitar madre de un dominio"
  echo "4) Elegir modo (round_robin / least_conn / ip_hash / failover)"
  echo "5) Activar / Desactivar balanceo por dominio"
  echo "0) Volver"
  echo
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1) pick_domain_for_manage && mothers_list "$PICKED_DOMAIN" ;;
    2) mothers_add ;;
    3) mothers_remove ;;
    4) mothers_set_mode ;;
    5) mothers_enable_disable ;;
    0) return 0 ;;
    *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}" ;;
  esac
  return 0
}

# ------------------ SPEED LIMIT ------------------
map_set_line() {
  local file="$1" key="$2" val="$3" mode="$4"
  local k="$key"
  [[ "$mode" == "quote" ]] && k="\"$key\""

  awk -v k="$k" '{ if($0 ~ "^[ \t]*"k"[ \t]+"){ next } print }' "$file" > "${file}.tmp" || true

  if [[ "$val" != "0" ]]; then
    printf "    %s %s;\n" "$k" "$val" >> "${file}.tmp"
  fi
  mv "${file}.tmp" "$file"
}

speed_limit_menu() {
  echo -e "${CYA}Limitar ancho de banda (limit_rate)${NC}"
  echo -e "${DIM}Formato: 512k, 2m, 10m. 0 = sin l√≠mite.${NC}\n"
  echo "1) Limitar por IP"
  echo "2) Limitar por Backend"
  echo "3) Limpiar l√≠mites (IP y Backend)"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1)
      read -r -p "IP: " ip
      validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return 0; }
      read -r -p "Velocidad (ej 2m, 512k, 0=unlimited): " rate
      validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return 0; }
      map_set_line "$NGX_LIMITS_IP" "$ip" "$rate" "noquote"
      ensure_http_conf_maps
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ OK.${NC}"
      return 0
      ;;
    2)
      read -r -p "Backend (ej svpnene38): " key
      validate_key "$key" || { echo -e "${RED}Backend inv√°lido.${NC}"; return 0; }
      read -r -p "Velocidad (ej 2m, 512k, 0=unlimited): " rate
      validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return 0; }
      map_set_line "$NGX_LIMITS_BACKEND" "$key" "$rate" "quote"
      ensure_http_conf_maps
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ OK.${NC}"
      return 0
      ;;
    3)
      : > "$NGX_LIMITS_IP"
      : > "$NGX_LIMITS_BACKEND"
      ensure_http_conf_maps
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ L√≠mites limpiados.${NC}"
      return 0
      ;;
    *) echo "Opci√≥n inv√°lida"; return 0 ;;
  esac
}

# ------------------ PICKS ------------------
pick_domain() {
  mapfile -t files < <(server_files)
  [[ "${#files[@]}" -gt 0 ]] || { echo -e "${YLW}No hay dominios creados.${NC}"; return 1; }
  echo -e "${CYA}Elegir dominio madre:${NC}"
  local i=0
  for f in "${files[@]}"; do
    i=$((i+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
    printf "%-3s) %s\n" "$i" "$dom"
  done
  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#files[@]} )) || return 1
  PICKED_DOMAIN_FILE="${files[$((n-1))]}"
  PICKED_DOMAIN="$(grep -E '^\s*server_name\s+' "$PICKED_DOMAIN_FILE" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
  [[ -n "${PICKED_DOMAIN:-}" ]] || return 1
  return 0
}

pick_backend() {
  mapfile -t lines < <(backend_lines)
  [[ "${#lines[@]}" -gt 0 ]] || { echo -e "${YLW}No hay backends.${NC}"; return 1; }
  echo -e "${CYA}Elegir backend:${NC}"
  local i=0
  for line in "${lines[@]}"; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-3s) %-20s -> %s:%s\n" "$i" "$key" "$ip" "$port"
  done
  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#lines[@]} )) || return 1
  line="${lines[$((n-1))]}"
  PICKED_BACKEND="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
  PICKED_BACKEND_URL="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
  return 0
}

# ------------------ DOMINIOS / SERVERS ------------------
create_server_for_domain() {
  local dom="$1"
  local file="${SERVERS_DIR}/${dom}.conf"
  local safe="${dom//./_}"

  local cto="${2:-300s}"
  local sto="${3:-600s}"
  local rto="${4:-600s}"

  cat > "$file" <<EOF
server {
    listen 80;
    listen [::]:80;

    server_name ${dom};

    access_log /var/log/nginx/${safe}.access.log;
    error_log  /var/log/nginx/${safe}.error.log;

    # Opcional: timeouts largos para backend
    proxy_connect_timeout ${cto};
    proxy_send_timeout    ${sto};
    proxy_read_timeout    ${rto};

    location / {
        include /etc/nginx/conf.d/backendmgr/targets/${dom}.conf;

        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        include /etc/nginx/conf.d/backendmgr/apply.conf;
    }
}
EOF
}

add_domain_auto_create() {
  echo -e "${CYA}Agregar dominio madre (AUTO crea server)${NC}"
  echo -e "${DIM}Ejemplo: cpu2.nenenet.site${NC}\n"
  read -r -p "Dominio madre nuevo: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return 0; }

  create_server_for_domain "$dom" "300s" "600s" "600s"
  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  rebuild_balancer_files
  ensure_domain_target_exists "$dom"
  nginx_test_reload
  echo -e "${GRN}‚úÖ Dominio madre creado:${NC} ${dom} (80)"
  return 0
}

create_or_edit_server_http() {
  echo -e "${CYA}Editar dominio madre (timeouts)${NC}"
  echo -e "${DIM}Enter = default 300/600/600.${NC}\n"

  read -r -p "Dominio (ej: cpu2.elnene.site): " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return 0; }

  read -r -p "proxy_connect_timeout (Enter=300s): " cto
  read -r -p "proxy_send_timeout    (Enter=600s): " sto
  read -r -p "proxy_read_timeout    (Enter=600s): " rto
  cto="${cto:-300s}"; sto="${sto:-600s}"; rto="${rto:-600s}"

  create_server_for_domain "$dom" "$cto" "$sto" "$rto"
  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  rebuild_balancer_files
  ensure_domain_target_exists "$dom"
  nginx_test_reload
  echo -e "${GRN}‚úÖ Actualizado:${NC} ${dom}"
  return 0
}

list_domains() {
  echo -e "${CYA}Dominios madre (servers)${NC}\n"
  mapfile -t files < <(server_files)
  [[ "${#files[@]}" -gt 0 ]] || { echo -e "${YLW}No hay dominios creados.${NC}"; return 0; }

  local idx=0
  for f in "${files[@]}"; do
    idx=$((idx+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/')"
    echo "$idx) $dom"
  done
  return 0
}

# ---- gesti√≥n de dominios madre (editar/eliminar) ----
pick_domain_for_manage() {
  mapfile -t files < <(server_files)
  [[ "${#files[@]}" -gt 0 ]] || { echo -e "${YLW}No hay dominios madre creados.${NC}"; return 1; }

  echo -e "${CYA}Elegir dominio madre:${NC}"
  local i=0
  for f in "${files[@]}"; do
    i=$((i+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
    printf "%-3s) %s\n" "$i" "$dom"
  done
  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#files[@]} )) || return 1

  PICKED_DOMAIN_FILE="${files[$((n-1))]}"
  PICKED_DOMAIN="$(grep -E '^\s*server_name\s+' "$PICKED_DOMAIN_FILE" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
  [[ -n "${PICKED_DOMAIN:-}" ]] || return 1
  return 0
}

edit_domain_pick() {
  echo -e "${CYA}Editar dominio madre (timeouts)${NC}"
  echo -e "${DIM}Eleg√≠s un dominio de la lista. Enter = default 300/600/600.${NC}\n"

  pick_domain_for_manage || return 0

  read -r -p "proxy_connect_timeout (Enter=300s): " cto
  read -r -p "proxy_send_timeout    (Enter=600s): " sto
  read -r -p "proxy_read_timeout    (Enter=600s): " rto
  cto="${cto:-300s}"; sto="${sto:-600s}"; rto="${rto:-600s}"

  create_server_for_domain "$PICKED_DOMAIN" "$cto" "$sto" "$rto"

  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  rebuild_balancer_files
  ensure_domain_target_exists "$PICKED_DOMAIN"
  nginx_test_reload

  echo -e "${GRN}‚úÖ Dominio actualizado:${NC} ${PICKED_DOMAIN}"
  return 0
}

delete_domain_pick() {
  echo -e "${CYA}Eliminar dominio madre${NC}"
  echo -e "${DIM}Borra el server .conf del dominio (no toca backends).${NC}\n"

  pick_domain_for_manage || return 0

  echo -e "${YLW}Vas a eliminar:${NC} ${PICKED_DOMAIN}"
  read -r -p "Confirmar (s/N): " yn
  case "${yn,,}" in
    s|si|s√≠|y|yes) ;;
    *) echo -e "${YLW}Cancelado.${NC}"; return 0 ;;
  esac

  rm -f "$PICKED_DOMAIN_FILE" || true
  rm -f "$(target_file "$PICKED_DOMAIN")" 2>/dev/null || true
  rm -f "$(mother_list_file "$PICKED_DOMAIN")" 2>/dev/null || true
  rm -f "$(mother_mode_file "$PICKED_DOMAIN")" 2>/dev/null || true

  rebuild_mothers_upstreams || true
  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  rebuild_balancer_files
  nginx_test_reload

  echo -e "${GRN}‚úÖ Dominio eliminado:${NC} ${PICKED_DOMAIN}"
  return 0
}

domains_menu() {
  while true; do
    echo -e "${CYA}Dominios madre${NC}"
    echo " 1) ‚ûï Agregar dominio madre (AUTO crea server)"
    echo " 2) ‚úèÔ∏è  Editar dominio madre (elegir de lista)"
    echo " 3) üóëÔ∏è  Eliminar dominio madre (elegir de lista)"
    echo " 4) üìÉ Listar dominios madre"
    echo " 0) Volver"
    echo
    read -r -p "Opci√≥n: " op
    echo
    case "$op" in
      1) add_domain_auto_create; pause ;;
      2) edit_domain_pick; pause ;;
      3) delete_domain_pick; pause ;;
      4) list_domains; pause ;;
      0) return 0 ;;
      *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}"; pause ;;
    esac
  done
}

# ------------------ BACKENDS ------------------
add_backend() {
  echo -e "${CYA}Agregar backend (nombre + IP + puerto)${NC}"
  echo -e "${DIM}Ejemplo: svpnene38 -> 179.43.112.38:80${NC}\n"

  read -r -p "Nombre del backend (ej: svpnene38): " key
  validate_key "$key" || { echo -e "${RED}Nombre inv√°lido.${NC}"; return 0; }

  read -r -p "IP (ej: 179.43.112.38): " ip
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return 0; }

  read -r -p "Puerto (ej: 80): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return 0; }

  local url="http://${ip}:${port}"

  if grep -qE "^\s*\"${key}\"" "$NGX_BACKENDS_MAP"; then
    awk -v k="$key" -v url="$url" '
      { re="^[ \t]*\""k"\"";
        if($0~re){ sub(/\"http:\\/\\/[^\\\"]+\"/, "\""url"\"") }
        print
      }' "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
    echo -e "${GRN}‚úÖ Actualizado:${NC} $key -> $ip:$port"
  else
    printf "        \"%s\" \"%s\";\n" "$key" "$url" >> "$NGX_BACKENDS_MAP"
    echo -e "${GRN}‚úÖ Agregado:${NC} $key -> $ip:$port"
  fi

  rebuild_balancer_files
  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  nginx_test_reload
  return 0
}

list_backends() {
  echo -e "${CYA}Backends (backend / IP / puerto)${NC}\n"
  printf "%-4s %-22s %-18s %-6s\n" "#" "BACKEND" "IP" "PORT"
  echo "--------------------------------------------------------------"
  local i=0

  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-4s %-22s %-18s %-6s\n" "$i" "$key" "$ip" "$port"
  done < <(backend_lines)

  if [[ "$i" -eq 0 ]]; then
    echo -e "${YLW}No hay backends cargados.${NC}"
  fi

  return 0
}

delete_backend_pick() {
  echo -e "${CYA}Eliminar backend${NC}\n"
  mapfile -t lines < <(backend_lines)
  [[ "${#lines[@]}" -gt 0 ]] || { echo -e "${YLW}No hay backends.${NC}"; return 0; }

  local i=0
  for line in "${lines[@]}"; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-3s) %-22s -> %s:%s\n" "$i" "$key" "$ip" "$port"
  done

  echo
  read -r -p "N√∫mero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return 0; }
  (( n>=1 && n<=${#lines[@]} )) || { echo -e "${RED}Fuera de rango.${NC}"; return 0; }

  target="${lines[$((n-1))]}"
  awk -v t="$target" '$0!=t{print}' "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" || true
  mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"

  rebuild_balancer_files
  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ Eliminado.${NC}"
  return 0
}

# ------------------ HEALTHCHECK ------------------
healthcheck_all() {
  read_cfg
  echo -e "${CYA}Healthcheck (HTTP y latencia)${NC}"
  echo -e "${DIM}HTTP 000 = no responde ‚Ä¢ timeout curl: ${CURL_TMO}s${NC}\n"
  printf "%-22s %-18s %-6s %-6s %-10s\n" "BACKEND" "IP" "PORT" "HTTP" "LAT(ms)"
  echo "------------------------------------------------------------------"
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    out="$(curl -m "$CURL_TMO" -s -o /dev/null -w "%{http_code} %{time_total}" "${url}/" || echo "000 9.999")"
    code="$(echo "$out" | awk '{print $1}')"
    t="$(echo "$out" | awk '{print $2}')"
    ms="$(awk -v x="$t" 'BEGIN{printf "%.0f", x*1000}')"
    printf "%-22s %-18s %-6s %-6s %-10s\n" "$key" "$ip" "$port" "$code" "$ms"
  done < <(backend_lines)
  return 0
}

# ------------------ VALIDAR CONEXI√ìN ------------------
validate_connection_test() {
  read_cfg
  echo -e "${CYA}Validar conexi√≥n (dominio ‚Üí backend por header)${NC}\n"
  pick_domain || return 0
  pick_backend || return 0

  echo
  echo -e "${WHT}Probando:${NC}"
  echo "  Dominio : ${PICKED_DOMAIN}"
  echo "  Header  : ${HEADER_NAME}: ${PICKED_BACKEND}"
  echo "  Backend : ${PICKED_BACKEND_URL}"
  echo

  echo -e "${DIM}1) Dominio responde:${NC}"
  curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" "http://${PICKED_DOMAIN}/" || true
  echo

  echo -e "${DIM}2) Dominio + header:${NC}"
  curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" -H "${HEADER_NAME}: ${PICKED_BACKEND}" "http://${PICKED_DOMAIN}/" || true
  echo

  echo -e "${DIM}3) Backend directo:${NC}"
  curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" "${PICKED_BACKEND_URL}/" || true
  echo
  return 0
}

# ------------------ TR√ÅFICO (IP / BACKEND) ------------------
traffic_stats() {
  read_cfg

  echo -e "${CYA}Tr√°fico (por IP o Backend)${NC}"
  echo -e "${DIM}Archivo: ${STATS_LOG}${NC}"
  if [[ "${TRAFFIC_STATS_ENABLED}" == "true" ]]; then
    if [[ -n "${TRAFFIC_STATS_SINCE}" ]]; then
      echo -e "${GRN}Estado: ACTIVADO${NC} (desde ${TRAFFIC_STATS_SINCE})"
    else
      echo -e "${GRN}Estado: ACTIVADO${NC}"
    fi
  else
    echo -e "${YLW}Estado: DESACTIVADO${NC}"
  fi
  echo

  echo "1) Por IP"
  echo "2) Por Backend (header)"
  echo "3) Activar logging de tr√°fico (stats)"
  echo "4) Desactivar logging de tr√°fico (stats)"
  echo "0) Volver"
  read -r -p "Opci√≥n: " op
  echo

  case "$op" in
    0) return 0 ;;
    3)
      if [[ "${TRAFFIC_STATS_ENABLED}" == "true" ]]; then
        echo -e "${YLW}Ya est√° activado.${NC}"
        return 0
      fi
      set_traffic_stats_enabled true
      echo -e "${GRN}‚úÖ Activado.${NC}"
      echo -e "${DIM}Desde ahora se acumula tr√°fico en:${NC} ${STATS_LOG}"
      return 0
      ;;
    4)
      if [[ "${TRAFFIC_STATS_ENABLED}" != "true" ]]; then
        echo -e "${YLW}Ya est√° desactivado.${NC}"
        return 0
      fi
      set_traffic_stats_enabled false
      echo -e "${GRN}‚úÖ Desactivado.${NC}"
      return 0
      ;;
    1|2)
      [[ -f "$STATS_LOG" ]] || { echo -e "${YLW}No existe todav√≠a: ${STATS_LOG}${NC}"; return 0; }

      local lines=5000
      read -r -p "Cantidad de l√≠neas a analizar (Enter=${lines}): " in
      lines="${in:-$lines}"
      echo

      if [[ "$op" == "1" ]]; then
        printf "%-18s %-12s %-10s\n" "IP" "TOTAL(MB)" "REQ"
        echo "---------------------------------------------"
        tail -n "$lines" "$STATS_LOG" | awk -F'|' '
          {ip=$2; bytes=$7; req[ip]+=1; b[ip]+=bytes}
          END{
            for(i in b){
              mb=b[i]/1024/1024;
              printf "%-18s %-12.2f %-10d\n", i, mb, req[i]
            }
          }' | sort -k2 -nr | head -n 30
      else
        printf "%-22s %-12s %-10s\n" "BACKEND" "TOTAL(MB)" "REQ"
        echo "---------------------------------------------------"
        tail -n "$lines" "$STATS_LOG" | awk -F'|' '
          {be=$4; if(be=="") be="(vac√≠o)"; bytes=$7; req[be]+=1; b[be]+=bytes}
          END{
            for(i in b){
              mb=b[i]/1024/1024;
              printf "%-22s %-12.2f %-10d\n", i, mb, req[i]
            }
          }' | sort -k2 -nr | head -n 30
      fi

      return 0
      ;;
    *) echo "Opci√≥n inv√°lida"; return 0 ;;
  esac
}

# ------------------ FIREWALL UFW ------------------
ufw_open_port() {
  echo -e "${CYA}Firewall UFW: permitir tr√°fico por puerto${NC}"
  echo -e "${DIM}Ejemplo: 80/tcp (HTTP) o 443/tcp (HTTPS).${NC}\n"

  command -v ufw >/dev/null 2>&1 || { echo -e "${YLW}UFW no est√° instalado. Instalalo con: apt install -y ufw${NC}"; return 0; }

  ufw status || true
  echo

  read -r -p "Puerto a habilitar (ej: 80 o 443): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return 0; }

  ufw allow "${port}/tcp" || true
  [[ "$port" == "80" ]] && ufw allow 'Nginx HTTP' || true
  [[ "$port" == "443" ]] && ufw allow 'Nginx Full' || true
  ufw reload || true

  echo -e "${GRN}‚úÖ Regla aplicada.${NC}"
  ufw status || true
  return 0
}

# ------------------ BACKUP / RESTORE ------------------
backup_bundle() {
  mkdir -p "$BACKUP_DIR"
  local out="${BACKUP_DIR}/bundle-$(date +%Y%m%d-%H%M%S).tar.gz"
  tar -czf "$out" \
    /etc/nginx/nginx.conf \
    /etc/nginx/conf.d/backendmgr \
    /etc/backendmgr \
    /var/lib/backendmgr 2>/dev/null || true
  echo -e "${GRN}‚úÖ Backup creado:${NC} $out"
  return 0
}

restore_bundle() {
  echo -e "${CYA}Restaurar backup${NC}"
  ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | nl -w2 -s') ' || { echo "No hay backups."; return 0; }
  read -r -p "N√∫mero: " n
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | sed -n "${n}p")"
  [[ -n "${file:-}" ]] || { echo -e "${YLW}Selecci√≥n inv√°lida.${NC}"; return 0; }

  echo -e "${YLW}‚ö†Ô∏è Backup preventivo antes de restaurar...${NC}"
  backup_bundle
  tar -xzf "$file" -C / 2>/dev/null || true
  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf
  rebuild_balancer_files
  rebuild_mothers_upstreams || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Restaurado.${NC}"
  return 0
}

# ------------------ Servicios Nginx ------------------
nginx_services_menu() {
  echo -e "${CYA}Servicios Nginx${NC}"
  echo " 1) Status"
  echo " 2) Stop (detener)"
  echo " 3) Start (reanudar)"
  echo " 4) Reload (recargar config)"
  echo " 5) Restart (reiniciar)"
  echo " 0) Volver"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1) systemctl status nginx --no-pager || true ;;
    2) systemctl stop nginx || true; echo -e "${GRN}‚úÖ Stop OK.${NC}" ;;
    3) systemctl start nginx || true; echo -e "${GRN}‚úÖ Start OK.${NC}" ;;
    4) nginx_test_reload; echo -e "${GRN}‚úÖ Reload OK.${NC}" ;;
    5) systemctl restart nginx || true; echo -e "${GRN}‚úÖ Restart OK.${NC}" ;;
    0) return 0 ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
  return 0
}
# ------------------ MANTENIMIENTO PROGRAMADO (RAM / NGINX) ------------------

have_systemd() { command -v systemctl >/dev/null 2>&1; }

systemd_write_unit() {
  local path="$1"
  local content="$2"
  echo "$content" > "$path"
}

systemd_reload_daemon() {
  have_systemd || return 0
  systemctl daemon-reload >/dev/null 2>&1 || true
}

systemd_enable_start_timer() {
  local t="$1"
  have_systemd || return 0
  systemctl enable --now "$t" >/dev/null 2>&1 || true
}

systemd_disable_stop_timer() {
  local t="$1"
  have_systemd || return 0
  systemctl disable --now "$t" >/dev/null 2>&1 || true
}

# -------- RAM refresh (drop_caches) --------
ramrefresh_units_names() {
  echo "backendmgr-ramrefresh.service backendmgr-ramrefresh.timer"
}

ramrefresh_install_or_update() {
  local every="$1"   # ej: 15min | 2h | 30min
  [[ -n "$every" ]] || return 0

  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è No hay systemd/systemctl. No puedo programarlo en este sistema.${NC}"
    return 0
  fi

  # Service
  systemd_write_unit "/etc/systemd/system/backendmgr-ramrefresh.service" \
"[Unit]
Description=BackendMgr RAM refresh (sync + drop caches)
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/bash -lc 'sync; echo 3 > /proc/sys/vm/drop_caches'
"

  # Timer
  systemd_write_unit "/etc/systemd/system/backendmgr-ramrefresh.timer" \
"[Unit]
Description=BackendMgr RAM refresh timer

[Timer]
OnBootSec=5min
OnUnitActiveSec=${every}
AccuracySec=1min
Persistent=true

[Install]
WantedBy=timers.target
"

  systemd_reload_daemon
  systemd_enable_start_timer "backendmgr-ramrefresh.timer"

  echo -e "${GRN}‚úÖ RAM refresh programado cada:${NC} ${every}"
  return 0
}

ramrefresh_disable() {
  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è No hay systemd/systemctl.${NC}"
    return 0
  fi

  systemd_disable_stop_timer "backendmgr-ramrefresh.timer"
  rm -f /etc/systemd/system/backendmgr-ramrefresh.timer /etc/systemd/system/backendmgr-ramrefresh.service 2>/dev/null || true
  systemd_reload_daemon
  echo -e "${GRN}‚úÖ RAM refresh desactivado.${NC}"
  return 0
}

ramrefresh_status() {
  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è No hay systemd/systemctl.${NC}"
    return 0
  fi

  systemctl status backendmgr-ramrefresh.timer --no-pager 2>/dev/null || true
  echo
  systemctl list-timers --all | grep -E 'backendmgr-ramrefresh' || true
  return 0
}

ramrefresh_menu() {
  echo -e "${CYA}Refresco de RAM programado (sync + drop_caches)${NC}"
  echo -e "${DIM}Crea un timer systemd que ejecuta: sync; echo 3 > /proc/sys/vm/drop_caches${NC}\n"
  echo "1) Activar / Cambiar intervalo"
  echo "2) Ver estado"
  echo "3) Desactivar"
  echo "0) Volver"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1)
      echo -e "${DIM}Ejemplos: 15min | 30min | 1h | 2h${NC}"
      read -r -p "Cada cu√°nto (formato systemd, ej 30min / 2h): " every
      [[ -n "${every:-}" ]] || { echo -e "${YLW}Cancelado.${NC}"; return 0; }
      ramrefresh_install_or_update "$every"
      ;;
    2) ramrefresh_status ;;
    3) ramrefresh_disable ;;
    0) return 0 ;;
    *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}" ;;
  esac
  return 0
}

# -------- Nginx: habilitar arranque + reload/restart programado --------
nginx_autostart_menu() {
  echo -e "${CYA}Nginx: arranque con el sistema${NC}\n"
  echo "1) Activar (enable)"
  echo "2) Desactivar (disable)"
  echo "3) Ver estado"
  echo "0) Volver"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1) systemctl enable nginx >/dev/null 2>&1 || true; echo -e "${GRN}‚úÖ Nginx habilitado al inicio.${NC}" ;;
    2) systemctl disable nginx >/dev/null 2>&1 || true; echo -e "${GRN}‚úÖ Nginx deshabilitado al inicio.${NC}" ;;
    3) systemctl is-enabled nginx 2>/dev/null || true; systemctl status nginx --no-pager 2>/dev/null || true ;;
    0) return 0 ;;
    *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}" ;;
  esac
  return 0
}

nginx_sched_write_units() {
  local action="$1"   # reload | restart
  local every="$2"    # 30min | 2h
  local svc="backendmgr-nginx-${action}.service"
  local tmr="backendmgr-nginx-${action}.timer"

  systemd_write_unit "/etc/systemd/system/${svc}" \
"[Unit]
Description=BackendMgr Nginx ${action} (safe)
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/bash -lc 'nginx -t && systemctl ${action} nginx'
"

  systemd_write_unit "/etc/systemd/system/${tmr}" \
"[Unit]
Description=BackendMgr Nginx ${action} timer

[Timer]
OnBootSec=5min
OnUnitActiveSec=${every}
AccuracySec=1min
Persistent=true

[Install]
WantedBy=timers.target
"
}

nginx_sched_enable() {
  local action="$1" every="$2"
  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è No hay systemd/systemctl.${NC}"
    return 0
  fi
  nginx_sched_write_units "$action" "$every"
  systemd_reload_daemon
  systemd_enable_start_timer "backendmgr-nginx-${action}.timer"
  echo -e "${GRN}‚úÖ Nginx ${action} programado cada:${NC} ${every}"
  return 0
}

nginx_sched_disable() {
  local action="$1"
  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è No hay systemd/systemctl.${NC}"
    return 0
  fi
  systemd_disable_stop_timer "backendmgr-nginx-${action}.timer"
  rm -f "/etc/systemd/system/backendmgr-nginx-${action}.timer" "/etc/systemd/system/backendmgr-nginx-${action}.service" 2>/dev/null || true
  systemd_reload_daemon
  echo -e "${GRN}‚úÖ Nginx ${action} desactivado.${NC}"
  return 0
}

nginx_sched_status() {
  local action="$1"
  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è No hay systemd/systemctl.${NC}"
    return 0
  fi
  systemctl status "backendmgr-nginx-${action}.timer" --no-pager 2>/dev/null || true
  echo
  systemctl list-timers --all | grep -E "backendmgr-nginx-${action}" || true
  return 0
}

nginx_sched_menu() {
  echo -e "${CYA}Nginx programado (reload/restart)${NC}"
  echo -e "${DIM}No borra configs: solo hace nginx -t y luego reload/restart.${NC}\n"
  echo "1) Programar RELOAD"
  echo "2) Desactivar RELOAD"
  echo "3) Estado RELOAD"
  echo "4) Programar RESTART"
  echo "5) Desactivar RESTART"
  echo "6) Estado RESTART"
  echo "0) Volver"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1)
      echo -e "${DIM}Ejemplos: 15min | 30min | 1h | 2h${NC}"
      read -r -p "Cada cu√°nto (ej 30min / 2h): " every
      [[ -n "${every:-}" ]] || { echo -e "${YLW}Cancelado.${NC}"; return 0; }
      nginx_sched_enable "reload" "$every"
      ;;
    2) nginx_sched_disable "reload" ;;
    3) nginx_sched_status "reload" ;;
    4)
      echo -e "${DIM}Ejemplos: 1h | 6h | 12h | 24h${NC}"
      read -r -p "Cada cu√°nto (ej 6h / 12h): " every
      [[ -n "${every:-}" ]] || { echo -e "${YLW}Cancelado.${NC}"; return 0; }
      nginx_sched_enable "restart" "$every"
      ;;
    5) nginx_sched_disable "restart" ;;
    6) nginx_sched_status "restart" ;;
    0) return 0 ;;
    *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}" ;;
  esac
  return 0
}

maintenance_menu() {
  if ! have_systemd; then
    echo -e "${YLW}‚ö†Ô∏è Este men√∫ requiere systemd/systemctl (Ubuntu normal s√≠ lo tiene).${NC}"
    return 0
  fi

  echo -e "${CYA}üß∞ Mantenimiento programado${NC}\n"
  echo "1) üß† Refresco RAM (drop_caches) programado"
  echo "2) ‚öôÔ∏è  Nginx: habilitar/deshabilitar arranque con el sistema"
  echo "3) üîÅ Nginx: programar reload/restart"
  echo "4) üìã Ver timers backendmgr"
  echo "0) Volver"
  read -r -p "Opci√≥n: " op
  echo
  case "$op" in
    1) ramrefresh_menu ;;
    2) nginx_autostart_menu ;;
    3) nginx_sched_menu ;;
    4) systemctl list-timers --all | grep -E 'backendmgr-' || { echo "No hay timers backendmgr."; } ;;
    0) return 0 ;;
    *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}" ;;
  esac
  return 0
}

speedtest_install_if_needed() {
  if command -v speedtest >/dev/null 2>&1; then
    return 0
  fi

  echo -e "${YLW}‚ö†Ô∏è Speedtest no est√° instalado.${NC}"
  echo -e "${DIM}Intento instalar speedtest-cli (apt).${NC}"

  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y >/dev/null 2>&1 || true
  apt-get install -y speedtest-cli >/dev/null 2>&1 || true

  if command -v speedtest >/dev/null 2>&1; then
    echo -e "${GRN}‚úÖ Speedtest instalado (speedtest-cli).${NC}"
    return 0
  fi

  echo -e "${RED}ERROR:${NC} No pude instalar speedtest-cli."
  echo -e "${DIM}Prob√° manualmente:${NC} apt-get update && apt-get install -y speedtest-cli"
  return 0
}

speedtest_menu() {
  echo -e "${CYA}Speedtest del servidor (Ping / Bajada / Subida)${NC}"
  echo -e "${DIM}Usa speedtest-cli. Puede tardar 20‚Äì60s seg√∫n red.${NC}\n"

  speedtest_install_if_needed

  if ! command -v speedtest >/dev/null 2>&1; then
    echo -e "${YLW}No se pudo ejecutar speedtest porque no est√° instalado.${NC}"
    return 0
  fi

  echo -e "${DIM}Ejecutando...${NC}\n"
  speedtest --simple || true
  return 0
}

# ------------------ MENU ------------------
menu() {
  echo -e "${WHT}üìå MEN√ö PRINCIPAL${NC}"
  echo "  1) üåê Dominios madre (crear / editar / eliminar)"
  echo "  2) ‚ûï Agregar backend (nombre + IP + puerto)"
  echo "  3) üìÑ Listar backends (backend / IP / puerto)"
  echo "  4) üåç Listar dominios madre (servers)"
  echo "  5) üóëÔ∏è  Eliminar backend"
  echo "  6) ‚úÖ Healthcheck (HTTP y latencia)"
  echo "  7) üß™ Validar conexi√≥n (dominio ‚Üí backend por header)"
  echo "  8) üß© Editar timeouts del dominio madre (manual por nombre)"
  echo "  9) ‚öñÔ∏è Balanceo de MADRES (VPS pool por dominio)"
  echo " 10) üö¶ Limitar ancho de banda por IP o Backend (limit_rate)"
  echo " 11) üìä Tr√°fico por IP / Backend (stats log)"
  echo " 12) üî• Firewall UFW: abrir puerto (80/443/otro)"
  echo " 13) üíæ Backup"
  echo " 14) ‚ôªÔ∏è  Restaurar backup"
  echo " 15) ‚öôÔ∏è  Servicios de Nginx (Status/Stop/Start/Reload/Restart)"
  echo " 16) üöÄ Speedtest (Ping / Bajada / Subida)"
  echo " 17) üß∞ Mantenimiento programado (RAM / Nginx timers)"
  echo "  0) üö™ Salir"
  echo
}

main() {
  need_root
  ensure_jq
  ensure_cfg
  ensure_files
  read_cfg

  ensure_http_conf_maps
  ensure_mothers_include
  write_apply_conf >/dev/null 2>&1 || true
  rebuild_balancer_files >/dev/null 2>&1 || true
  rebuild_mothers_upstreams >/dev/null 2>&1 || true

  while true; do
    banner
    menu
    read -r -p "Opci√≥n: " opt
    echo

    case "$opt" in
      1) domains_menu ;;
      2) add_backend; pause ;;
      3) list_backends; pause ;;
      4) list_domains; pause ;;
      5) delete_backend_pick; pause ;;
      6) healthcheck_all; pause ;;
      7) validate_connection_test; pause ;;
      8) create_or_edit_server_http; pause ;;
      9) mothers_menu; pause ;;
     10) speed_limit_menu; pause ;;
     11) traffic_stats; pause ;;
     12) ufw_open_port; pause ;;
     13) backup_bundle; pause ;;
     14) restore_bundle; pause ;;
     15) nginx_services_menu; pause ;;
     16) speedtest_menu; pause ;;
     17) maintenance_menu; pause ;;
      0) exit 0 ;;
      *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}"; pause ;;
    esac
  done
}

main
