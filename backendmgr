#!/usr/bin/env bash
set -euo pipefail

APP_NAME="Backend Manager Nenenet 3.0"
APP_VER="3.0.2"

CFG_FILE="/etc/backendmgr/config.json"
BACKUP_DIR="/root/backendmgr-backups"

NGX_DIR="/etc/nginx/conf.d/backendmgr"
NGX_MAIN_INCLUDE="${NGX_DIR}/backendmgr.conf"
NGX_BACKENDS_MAP="${NGX_DIR}/backends.map"
NGX_DOMAINS_MAP="${NGX_DIR}/domains.map"
NGX_DEFAULTS_MAP="${NGX_DIR}/defaults.map"
NGX_LOGGING_SNIP="${NGX_DIR}/logging.conf"
NGX_APPLY_SNIP="${NGX_DIR}/apply.conf"

NGX_BALANCER_CONF="${NGX_DIR}/balancer.conf"
NGX_BALANCED_MAP="${NGX_DIR}/balanced.map"
NGX_LIMITS_IP="${NGX_DIR}/limits_ip.map"
NGX_LIMITS_BACKEND="${NGX_DIR}/limits_backend.map"
NGX_LIMITS_URL="${NGX_DIR}/limits_url.map"

NC='\033[0m'
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
CYA='\033[0;36m'
WHT='\033[1;37m'
DIM='\033[2m'

need_root() { [[ ${EUID:-999} -eq 0 ]] || { echo -e "${RED}ERROR:${NC} ejecut√°: sudo nginx"; exit 1; }; }
pause() { echo; read -r -p "Enter para continuar..." _; }
die() { echo -e "${RED}ERROR:${NC} $*"; exit 1; }

nginx_test_reload() { nginx -t && systemctl reload nginx; }
nginx_active() { systemctl is-active --quiet nginx && echo "ACTIVO" || echo "INACTIVO"; }

read_cfg() {
  [[ -f "$CFG_FILE" ]] || die "Falta $CFG_FILE. Instal√° con install.sh"
  HEADER_NAME="$(jq -r '.header_name' "$CFG_FILE")"
  RL_ENABLED="$(jq -r '.rate_limit_enabled' "$CFG_FILE")"
  RL_RATE="$(jq -r '.rate_limit_rate' "$CFG_FILE")"
  RL_BURST="$(jq -r '.rate_limit_burst' "$CFG_FILE")"
  CONN_LIMIT="$(jq -r '.conn_limit' "$CFG_FILE")"
  CURL_TMO="$(jq -r '.curl_timeout_seconds' "$CFG_FILE")"
  WINDOW_SEC="$(jq -r '.traffic_window_seconds' "$CFG_FILE")"
  STATS_LOG="$(jq -r '.stats_log_path' "$CFG_FILE")"
  BAL_MODE="$(jq -r '.balance_mode' "$CFG_FILE")"
  BAL_CAP="$(jq -r '.balance_max_slots_cap' "$CFG_FILE")"
}

ensure_files() {
  mkdir -p "$NGX_DIR" "/var/lib/backendmgr" "$BACKUP_DIR"
  chmod 700 "$BACKUP_DIR" || true

  for f in "$NGX_MAIN_INCLUDE" "$NGX_BACKENDS_MAP" "$NGX_DOMAINS_MAP" "$NGX_DEFAULTS_MAP" "$NGX_LOGGING_SNIP" \
           "$NGX_APPLY_SNIP" "$NGX_BALANCER_CONF" "$NGX_BALANCED_MAP" \
           "$NGX_LIMITS_IP" "$NGX_LIMITS_BACKEND" "$NGX_LIMITS_URL"
  do
    [[ -f "$f" ]] || : > "$f"
  done
}

banner() {
  clear
  echo -e "${CYA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${CYA}‚ïë${NC}  üöÄ ${APP_NAME}  v${APP_VER}                                   ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïë${NC}  Header: ${WHT}${HEADER_NAME}${NC} | Balance: ${WHT}${BAL_MODE}${NC} | Limits: IP/Backend/URL      ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo
}

quick_status() {
  echo -e "${WHT}üìä ESTADO${NC}"
  echo -e "   üß© Nginx: ${GRN}$(nginx_active)${NC}"
  echo -e "   ‚öñÔ∏è Balance: ${GRN}${BAL_MODE}${NC}"
  echo -e "   üõ°Ô∏è RateLimit: ${GRN}${RL_ENABLED}${NC} (${RL_RATE}, burst ${RL_BURST}, conn ${CONN_LIMIT})"
  echo -e "   üìà Stats log: ${DIM}${STATS_LOG}${NC}"
  echo
}

# ---------------- FIX: maps multil√≠nea (para que opciones 1/2/3 funcionen) ----------------
normalize_domains_map() {
  if grep -qE 'map\s+\$host\s+\$backend_domain\s*\{[^}]*\}' "$NGX_DOMAINS_MAP"; then
    cat > "$NGX_DOMAINS_MAP" <<'EOF'
map $host $backend_domain {
    default "_default";
}
EOF
  fi
}

normalize_defaults_map() {
  if grep -qE 'map\s+\$backend_domain\s+\$default_backend_url\s*\{[^}]*\}' "$NGX_DEFAULTS_MAP"; then
    cat > "$NGX_DEFAULTS_MAP" <<'EOF'
map $backend_domain $default_backend_url {
    default "http://127.0.0.1:8880";
}
EOF
  fi
}

normalize_balancer_default() {
  # FIX: evita "set" en http{}
  if grep -qE '^\s*set\s+\$backendmgr_slot' "$NGX_BALANCER_CONF"; then
    cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (balance OFF)
map $host $backendmgr_balance { default 0; }
map $host $backendmgr_slot { default "0"; }

map "$backend_domain:$backendmgr_slot" $balanced_backend_url {
    default $default_backend_url;
}
EOF
  fi
}

normalize_all_maps() {
  normalize_domains_map
  normalize_defaults_map
  normalize_balancer_default
}

# ---------------- Backup/Restore ----------------
backup_bundle() {
  mkdir -p "$BACKUP_DIR"
  local out="${BACKUP_DIR}/bundle-$(date +%Y%m%d-%H%M%S).tar.gz"
  tar -czf "$out" /etc/nginx /etc/backendmgr /var/lib/backendmgr 2>/dev/null || true
  echo -e "${GRN}‚úÖ Backup creado:${NC} $out"
}

restore_bundle() {
  echo -e "${CYA}Restaurar backup${NC}"
  ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | nl -w2 -s') ' || { echo "No hay backups."; return; }
  echo
  read -r -p "N√∫mero: " n
  local file
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | sed -n "${n}p")"
  [[ -n "${file:-}" ]] || { echo -e "${YLW}Selecci√≥n inv√°lida.${NC}"; return; }

  echo -e "${YLW}‚ö†Ô∏è Backup de seguridad antes de restaurar.${NC}"
  backup_bundle
  tar -xzf "$file" -C / 2>/dev/null || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Restaurado.${NC}"
}

# ---------------- Validaciones ----------------
validate_domain() { [[ "$1" =~ ^[A-Za-z0-9.-]{3,253}$ ]]; }
validate_key() { [[ "$1" =~ ^[A-Za-z0-9_.:-]{2,64}$ ]]; }
validate_url() { [[ "$1" =~ ^http://[A-Za-z0-9._-]+:[0-9]{2,5}$ ]]; }
validate_ip() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }
validate_rate() { [[ "$1" == "0" || "$1" =~ ^[0-9]+[kKmM]$ ]]; }

# ---------------- Dominios ----------------
list_domains() {
  echo -e "${WHT}Dominios registrados:${NC}"
  grep -E '^\s*"[A-Za-z0-9.-]+"\s+"' "$NGX_DOMAINS_MAP" 2>/dev/null \
    | sed -E 's/^\s*"([^"]+)".*$/\1/' | sort -u || true
}

add_domain() {
  echo -e "${CYA}Agregar dominio${NC}"
  read -r -p "Dominio: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }

  if ! grep -qE "^\s*\"${dom//\./\\.}\"" "$NGX_DOMAINS_MAP"; then
    awk -v dom="$dom" '
      BEGIN{done=0}
      /^\}\s*$/ && !done { printf "    \"%s\" \"%s\";\n", dom, dom; done=1 }
      {print}
    ' "$NGX_DOMAINS_MAP" > "${NGX_DOMAINS_MAP}.tmp" && mv "${NGX_DOMAINS_MAP}.tmp" "$NGX_DOMAINS_MAP"
  fi

  if ! grep -qE "^\s*\"${dom//\./\\.}\"" "$NGX_DEFAULTS_MAP"; then
    awk -v dom="$dom" '
      BEGIN{done=0}
      /^\}\s*$/ && !done { printf "    \"%s\" \"http://127.0.0.1:8880\";\n", dom; done=1 }
      {print}
    ' "$NGX_DEFAULTS_MAP" > "${NGX_DEFAULTS_MAP}.tmp" && mv "${NGX_DEFAULTS_MAP}.tmp" "$NGX_DEFAULTS_MAP"
  fi

  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Dominio listo.${NC}"
}

# ---------------- Backends ----------------
list_backends_for_domain() {
  read -r -p "Dominio: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }

  echo -e "${WHT}Backends de ${dom}:${NC}"
  printf "%-22s %-38s\n" "KEY" "URL"
  echo "---------------------------------------------------------------"
  grep -E "^\s*\"${dom//\./\\.}:" "$NGX_BACKENDS_MAP" 2>/dev/null \
    | sed -E "s/^\s*\"${dom//\./\\.}:(.+)\"\s+\"(.+)\";.*/\1\t\2/" \
    | awk -F'\t' '{ printf "%-22s %-38s\n", $1, $2 }' || true
}

add_or_update_backend() {
  echo -e "${CYA}Agregar / Actualizar backend${NC}"
  read -r -p "Dominio: " dom
  read -r -p "Backend key (ej: svpnene38): " key
  read -r -p "IP (ej: 179.43.112.38): " ip
  read -r -p "Puerto (ej: 80): " port

  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }
  validate_key "$key" || { echo -e "${RED}Key inv√°lida.${NC}"; return; }
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return; }
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return; }

  local url="http://${ip}:${port}"
  local dk="${dom}:${key}"

  if grep -qE "^\s*\"${dk//\./\\.}\"" "$NGX_BACKENDS_MAP"; then
    awk -v dk="$dk" -v url="$url" '{ re="^[ \t]*\""dk"\""; if($0 ~ re){ sub(/"http:\/\/[^"]+"/, "\""url"\"") } print }' \
      "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
  else
    printf "    \"%s\" \"%s\";\n" "$dk" "$url" >> "$NGX_BACKENDS_MAP"
  fi

  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Guardado.${NC}"
}

delete_backend() {
  echo -e "${CYA}Eliminar backend${NC}"
  read -r -p "Dominio: " dom
  read -r -p "Key: " key
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }
  validate_key "$key" || { echo -e "${RED}Key inv√°lida.${NC}"; return; }

  local dk="${dom}:${key}"
  grep -vE "^\s*\"${dk//\./\\.}\"" "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"

  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Eliminado.${NC}"
}

# ---------------- Wizard inicial ----------------
wizard_setup() {
  echo -e "${CYA}Asistente Inicial (1 dominio + 1 backend)${NC}"
  echo

  read -r -p "Dominio (ej: cpu2.elnene.site): " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }

  read -r -p "Backend key (ej: svpnene38): " key
  validate_key "$key" || { echo -e "${RED}Key inv√°lida.${NC}"; return; }

  read -r -p "IP (ej: 179.43.112.38): " ip
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return; }

  read -r -p "Puerto (ej: 80): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return; }

  # crea dominio si falta
  if ! grep -qE "^\s*\"${dom//\./\\.}\"" "$NGX_DOMAINS_MAP"; then
    awk -v dom="$dom" '
      BEGIN{done=0}
      /^\}\s*$/ && !done { printf "    \"%s\" \"%s\";\n", dom, dom; done=1 }
      {print}
    ' "$NGX_DOMAINS_MAP" > "${NGX_DOMAINS_MAP}.tmp" && mv "${NGX_DOMAINS_MAP}.tmp" "$NGX_DOMAINS_MAP"
  fi

  if ! grep -qE "^\s*\"${dom//\./\\.}\"" "$NGX_DEFAULTS_MAP"; then
    awk -v dom="$dom" '
      BEGIN{done=0}
      /^\}\s*$/ && !done { printf "    \"%s\" \"http://127.0.0.1:8880\";\n", dom; done=1 }
      {print}
    ' "$NGX_DEFAULTS_MAP" > "${NGX_DEFAULTS_MAP}.tmp" && mv "${NGX_DEFAULTS_MAP}.tmp" "$NGX_DEFAULTS_MAP"
  fi

  # agrega backend
  local url="http://${ip}:${port}"
  local dk="${dom}:${key}"
  printf "    \"%s\" \"%s\";\n" "$dk" "$url" >> "$NGX_BACKENDS_MAP"

  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true
  nginx_test_reload

  echo -e "${GRN}‚úÖ Asistente completado.${NC}"
}

# ---------------- Healthcheck ----------------
healthcheck_all() {
  echo -e "${CYA}Healthcheck (todos)${NC}"
  echo -e "${DIM}curl timeout: ${CURL_TMO}s${NC}"
  echo
  printf "%-22s %-18s %-26s %-8s %-10s\n" "DOMINIO" "KEY" "URL" "HTTP" "LAT(ms)"
  echo "-------------------------------------------------------------------------------------"

  grep -E '^\s*"[A-Za-z0-9.-]+:[A-Za-z0-9_.:-]+"\s+"http://' "$NGX_BACKENDS_MAP" 2>/dev/null | while read -r line; do
    domkey="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    dom="${domkey%%:*}"
    key="${domkey#*:}"

    out="$(curl -m "$CURL_TMO" -s -o /dev/null -w "%{http_code} %{time_total}" "${url}/" || echo "000 9.999")"
    code="$(echo "$out" | awk '{print $1}')"
    t="$(echo "$out" | awk '{print $2}')"
    ms="$(awk -v x="$t" 'BEGIN{printf "%.0f", x*1000}')"

    printf "%-22s %-18s %-26s %-8s %-10s\n" "$dom" "$key" "$url" "$code" "$ms"
  done
}

# ---------------- Rate-limit req/conn ----------------
rewrite_rate_zone() {
  if grep -qE '^\s*limit_req_zone\s+\$binary_remote_addr\s+zone=backendmgr_req:10m\s+rate=' "$NGX_MAIN_INCLUDE"; then
    awk -v rate="$RL_RATE" '
      { if($0 ~ /^\s*limit_req_zone\s+\$binary_remote_addr\s+zone=backendmgr_req:10m\s+rate=/){ sub(/rate=[^;]+;/, "rate="rate";") } print }
    ' "$NGX_MAIN_INCLUDE" > "${NGX_MAIN_INCLUDE}.tmp" && mv "${NGX_MAIN_INCLUDE}.tmp" "$NGX_MAIN_INCLUDE"
  fi
}

rate_limit_menu() {
  echo -e "${CYA}Rate Limit (requests/connections)${NC}"
  echo "Estado:     $RL_ENABLED"
  echo "Rate:       $RL_RATE"
  echo "Burst:      $RL_BURST"
  echo "Conn limit: $CONN_LIMIT"
  echo
  echo "1) Activar / Desactivar"
  echo "2) Cambiar rate (ej: 10r/s)"
  echo "3) Cambiar burst"
  echo "4) Cambiar conn limit"
  echo "5) Aplicar"
  read -r -p "Opci√≥n: " op

  case "$op" in
    1)
      if [[ "$RL_ENABLED" == "true" ]]; then RL_ENABLED="false"; else RL_ENABLED="true"; fi
      jq ".rate_limit_enabled = ${RL_ENABLED}" "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      ;;
    2)
      read -r -p "Nuevo rate: " v
      [[ "$v" =~ ^[0-9]+r/s$ ]] || { echo -e "${RED}Formato inv√°lido (ej: 10r/s).${NC}"; return; }
      jq --arg v "$v" '.rate_limit_rate = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      ;;
    3)
      read -r -p "Nuevo burst: " v
      [[ "$v" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return; }
      jq --argjson v "$v" '.rate_limit_burst = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      ;;
    4)
      read -r -p "Nuevo conn limit: " v
      [[ "$v" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return; }
      jq --argjson v "$v" '.conn_limit = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      ;;
    5)
      read_cfg
      rewrite_rate_zone
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ Aplicado.${NC}"
      ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ---------------- Balanceador ----------------
get_domains_list() {
  grep -E '^\s*"[A-Za-z0-9.-]+"\s+"' "$NGX_DOMAINS_MAP" 2>/dev/null | sed -E 's/^\s*"([^"]+)".*$/\1/' | sort -u
}

count_backends_for_domain() {
  local dom="$1"
  grep -cE "^\s*\"${dom//\./\\.}:" "$NGX_BACKENDS_MAP" 2>/dev/null || echo 0
}

rebuild_balancer_files() {
  read_cfg
  local cap="$BAL_CAP"
  [[ "$cap" =~ ^[0-9]+$ ]] || cap=64

  local max=0 d c
  while read -r d; do
    [[ -z "$d" ]] && continue
    c="$(count_backends_for_domain "$d")"
    (( c > max )) && max="$c"
  done < <(get_domains_list)

  (( max < 2 )) && max=2
  (( max > cap )) && max="$cap"

  : > "$NGX_BALANCED_MAP"
  while read -r d; do
    [[ -z "$d" ]] && continue
    mapfile -t urls < <(grep -E "^\s*\"${d//\./\\.}:" "$NGX_BACKENDS_MAP" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')
    local i=0
    for u in "${urls[@]}"; do
      [[ $i -ge $max ]] && break
      printf "    \"%s:%s\" \"%s\";\n" "$d" "$i" "$u" >> "$NGX_BALANCED_MAP"
      i=$((i+1))
    done
  done < <(get_domains_list)

  if [[ "$BAL_MODE" == "off" ]]; then
    cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (balance OFF)
map $host $backendmgr_balance { default 0; }
map $host $backendmgr_slot { default "0"; }

map "$backend_domain:$backendmgr_slot" $balanced_backend_url {
    default $default_backend_url;
}
EOF
    return 0
  fi

  local split_key
  case "$BAL_MODE" in
    iphash) split_key='$remote_addr' ;;
    random) split_key='$remote_addr$msec$connection' ;;
    *) split_key='$remote_addr' ;;
  esac

  local base=$((100 / max))
  local rem=$((100 - base * max))

  {
    echo "# backendmgr balancer.conf (balance: ${BAL_MODE})"
    echo "map \$host \$backendmgr_balance { default 1; }"
    echo "split_clients \"${split_key}\" \$backendmgr_slot {"
    for ((i=0;i<max;i++)); do
      pct="$base"
      if (( rem > 0 )); then pct=$((pct+1)); rem=$((rem-1)); fi
      echo "    ${pct}% \"${i}\";"
    done
    echo "}"
    echo "map \"\$backend_domain:\$backendmgr_slot\" \$balanced_backend_url {"
    echo "    default \$default_backend_url;"
    echo "    include ${NGX_BALANCED_MAP};"
    echo "}"
  } > "$NGX_BALANCER_CONF"
}

set_balance_mode() {
  echo -e "${CYA}Balanceador (equilibrar tr√°fico)${NC}"
  echo "1) OFF (por header Backend)"
  echo "2) RANDOM (reparte por request)"
  echo "3) STICKY-IP (iphash)"
  read -r -p "Opci√≥n: " op
  case "$op" in
    1) BAL_MODE="off" ;;
    2) BAL_MODE="random" ;;
    3) BAL_MODE="iphash" ;;
    *) echo "Inv√°lida"; return ;;
  esac
  jq --arg v "$BAL_MODE" '.balance_mode = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
  rebuild_balancer_files
  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ Balance: ${BAL_MODE}${NC}"
}

# ---------------- Limits (speed) ----------------
write_apply_conf() {
  read_cfg
  rewrite_rate_zone >/dev/null 2>&1 || true

  cat > "$NGX_APPLY_SNIP" <<EOF_APPLY
# ${APP_NAME} apply.conf
# Incluir dentro de location / :
# include /etc/nginx/conf.d/backendmgr/apply.conf;

# Stats log
access_log ${STATS_LOG} backendmgr_stats;

# Balance: si est√° activo, pisa backend_url por el balanceado
if (\$backendmgr_balance = 1) {
    set \$backend_url \$balanced_backend_url;
}

EOF_APPLY

  if [[ "$RL_ENABLED" == "true" ]]; then
    cat >> "$NGX_APPLY_SNIP" <<EOF_RL
limit_req zone=backendmgr_req burst=${RL_BURST} nodelay;
limit_conn backendmgr_conn ${CONN_LIMIT};

EOF_RL
  else
    cat >> "$NGX_APPLY_SNIP" <<'EOF_OFF'
# rate-limit desactivado
EOF_OFF
  fi

  cat >> "$NGX_APPLY_SNIP" <<'EOF_LIMITS'
# Speed limits (0 = unlimited)
# prioridad: Backend(dom:key) > URL(actual) > IP
set $nenenet_rate 0;

if ($backend_limit_rate != 0) { set $nenenet_rate $backend_limit_rate; }
if ($nenenet_rate = 0) { if ($url_limit_rate != 0) { set $nenenet_rate $url_limit_rate; } }
if ($nenenet_rate = 0) { if ($ip_limit_rate != 0) { set $nenenet_rate $ip_limit_rate; } }

limit_rate $nenenet_rate;
EOF_LIMITS
}

limits_list() {
  echo -e "${WHT}L√≠mites por IP:${NC} ${DIM}${NGX_LIMITS_IP}${NC}"
  sed -n '1,160p' "$NGX_LIMITS_IP" 2>/dev/null || true
  echo
  echo -e "${WHT}L√≠mites por Backend (dom:key):${NC} ${DIM}${NGX_LIMITS_BACKEND}${NC}"
  sed -n '1,160p' "$NGX_LIMITS_BACKEND" 2>/dev/null || true
  echo
  echo -e "${WHT}L√≠mites por URL (http://ip:port):${NC} ${DIM}${NGX_LIMITS_URL}${NC}"
  sed -n '1,160p' "$NGX_LIMITS_URL" 2>/dev/null || true
}

limit_ip_set() {
  echo -e "${CYA}Set l√≠mite por IP${NC}"
  read -r -p "IP: " ip
  read -r -p "Rate (0=unlimited, 500k, 1m, 5m): " rate
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return; }
  validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return; }

  if grep -qE "^\s*${ip}\s+" "$NGX_LIMITS_IP"; then
    awk -v ip="$ip" -v r="$rate" '{ if($1==ip){ print ip" "r";" } else print }' "$NGX_LIMITS_IP" > "${NGX_LIMITS_IP}.tmp" && mv "${NGX_LIMITS_IP}.tmp" "$NGX_LIMITS_IP"
  else
    echo "${ip} ${rate};" >> "$NGX_LIMITS_IP"
  fi

  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ OK.${NC}"
}

limit_backend_set() {
  echo -e "${CYA}Set l√≠mite por Backend (dom:key)${NC}"
  read -r -p "Dominio: " dom
  read -r -p "Key: " key
  read -r -p "Rate (0=unlimited, 500k, 1m, 5m): " rate
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }
  validate_key "$key" || { echo -e "${RED}Key inv√°lida.${NC}"; return; }
  validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return; }

  local dk="${dom}:${key}"
  if grep -qE "^\s*\"${dk//\./\\.}\"" "$NGX_LIMITS_BACKEND"; then
    awk -v dk="$dk" -v r="$rate" '{ re="^[ \t]*\""dk"\""; if($0 ~ re){ print "    \""dk"\" "r";" } else print }' \
      "$NGX_LIMITS_BACKEND" > "${NGX_LIMITS_BACKEND}.tmp" && mv "${NGX_LIMITS_BACKEND}.tmp" "$NGX_LIMITS_BACKEND"
  else
    echo "    \"${dk}\" ${rate};" >> "$NGX_LIMITS_BACKEND"
  fi

  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ OK.${NC}"
}

limit_url_set() {
  echo -e "${CYA}Set l√≠mite por URL (http://ip:port)${NC}"
  read -r -p "URL: " url
  read -r -p "Rate (0=unlimited, 500k, 1m, 5m): " rate
  validate_url "$url" || { echo -e "${RED}URL inv√°lida.${NC}"; return; }
  validate_rate "$rate" || { echo -e "${RED}Rate inv√°lido.${NC}"; return; }

  if grep -qE "^\s*\"${url//\//\\/}\"" "$NGX_LIMITS_URL"; then
    awk -v u="$url" -v r="$rate" '{ re="^[ \t]*\""u"\""; if($0 ~ re){ print "    \""u"\" "r";" } else print }' \
      "$NGX_LIMITS_URL" > "${NGX_LIMITS_URL}.tmp" && mv "${NGX_LIMITS_URL}.tmp" "$NGX_LIMITS_URL"
  else
    echo "    \"${url}\" ${rate};" >> "$NGX_LIMITS_URL"
  fi

  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ OK.${NC}"
}

limits_menu() {
  echo -e "${CYA}Limitar velocidad (bandwidth)${NC}"
  echo "1) Ver l√≠mites"
  echo "2) Set por IP"
  echo "3) Set por Backend (dom:key)"
  echo "4) Set por URL (http://ip:port)"
  read -r -p "Opci√≥n: " op
  case "$op" in
    1) limits_list ;;
    2) limit_ip_set ;;
    3) limit_backend_set ;;
    4) limit_url_set ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ---------------- Tr√°fico (simple) ----------------
traffic_by_ip() {
  echo -e "${CYA}Tr√°fico por IP (√∫ltimos ${WINDOW_SEC}s)${NC}"
  [[ -f "$STATS_LOG" ]] || { echo -e "${YLW}No existe stats log:${NC} $STATS_LOG"; echo "Inclu√≠ apply.conf en location / y recarg√° nginx."; return; }

  local now cut
  now="$(date +%s)"; cut=$((now - WINDOW_SEC))

  tail -n 20000 "$STATS_LOG" | gawk -F'\\|' -v cut="$cut" '
    function mon(m){ return index("JanFebMarAprMayJunJulAugSepOctNovDec", m)/3 }
    function toEpoch(t,   d,mo,y,h,mi,s){
      split(t,a,"[:/ ]"); d=a[1]; mo=mon(a[2]); y=a[3]; h=a[4]; mi=a[5]; s=a[6]
      return mktime(y" "mo" "d" "h" "mi" "s)
    }
    { e=toEpoch($1); ip=$2; bytes=$8+0; if(e>=cut){ sum[ip]+=bytes } }
    END{ for(ip in sum) printf "%s\t%.0f\n", ip, sum[ip] }
  ' | sort -k2 -nr | head -n 25
}

traffic_by_backend() {
  echo -e "${CYA}Tr√°fico por Backend (√∫ltimos ${WINDOW_SEC}s)${NC}"
  [[ -f "$STATS_LOG" ]] || { echo -e "${YLW}No existe stats log:${NC} $STATS_LOG"; echo "Inclu√≠ apply.conf en location / y recarg√° nginx."; return; }

  local now cut
  now="$(date +%s)"; cut=$((now - WINDOW_SEC))

  tail -n 20000 "$STATS_LOG" | gawk -F'\\|' -v cut="$cut" '
    function mon(m){ return index("JanFebMarAprMayJunJulAugSepOctNovDec", m)/3 }
    function toEpoch(t,   d,mo,y,h,mi,s){
      split(t,a,"[:/ ]"); d=a[1]; mo=mon(a[2]); y=a[3]; h=a[4]; mi=a[5]; s=a[6]
      return mktime(y" "mo" "d" "h" "mi" "s)
    }
    { e=toEpoch($1); dom=$4; key=$5; bytes=$8+0; if(e>=cut){ sum[dom":"key]+=bytes } }
    END{ for(k in sum) printf "%s\t%.0f\n", k, sum[k] }
  ' | sort -k2 -nr | head -n 25
}

traffic_menu() {
  echo -e "${CYA}Tr√°fico${NC}"
  echo "1) Por IP"
  echo "2) Por Backend (dom:key)"
  read -r -p "Opci√≥n: " op
  case "$op" in
    1) traffic_by_ip ;;
    2) traffic_by_backend ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

main_menu() {
  echo -e "${WHT}üìå MEN√ö PRINCIPAL${NC}"
  echo "  1) üßô Asistente inicial (dominio + backend)"
  echo "  2) üåê Dominios: listar"
  echo "  3) üåê Dominios: agregar"
  echo "  4) üìÑ Backends: listar por dominio"
  echo "  5) ‚ûï Backends: agregar/actualizar"
  echo "  6) üóëÔ∏è  Backends: eliminar"
  echo "  7) ‚úÖ Healthcheck: todos"
  echo "  8) üõ°Ô∏è Rate limit (req/conn)"
  echo "  9) ‚öñÔ∏è Balanceador (OFF/RANDOM/STICKY-IP)"
  echo " 10) üö¶ Limitar velocidad (IP/Backend/URL)"
  echo " 11) üìä Tr√°fico (IP o Backend)"
  echo " 12) üíæ Backup completo"
  echo " 13) ‚ôªÔ∏è  Restaurar backup"
  echo " 14) üîÑ Reload Nginx"
  echo " 15) ‚ôªÔ∏è  Restart Nginx"
  echo "  0) üö™ Salir"
  echo
}

main() {
  need_root
  read_cfg
  ensure_files
  normalize_all_maps
  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true

  while true; do
    banner
    quick_status
    main_menu
    read -r -p "Opci√≥n: " opt
    echo
    case "$opt" in
      1) wizard_setup; pause ;;
      2) list_domains; pause ;;
      3) add_domain; pause ;;
      4) list_backends_for_domain; pause ;;
      5) add_or_update_backend; pause ;;
      6) delete_backend; pause ;;
      7) healthcheck_all; pause ;;
      8) rate_limit_menu; pause ;;
      9) set_balance_mode; pause ;;
      10) limits_menu; pause ;;
      11) traffic_menu; pause ;;
      12) backup_bundle; pause ;;
      13) restore_bundle; pause ;;
      14) nginx_test_reload; echo -e "${GRN}‚úÖ Reload OK.${NC}"; pause ;;
      15) nginx -t && systemctl restart nginx; echo -e "${GRN}‚úÖ Restart OK.${NC}"; pause ;;
      0) exit 0 ;;
      *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}"; pause ;;
    esac
  done
}

main
