#!/usr/bin/env bash
set -euo pipefail

APP_NAME="Backend Manager Nenenet 3.0"
APP_VER="4.3"

CFG_FILE="/etc/backendmgr/config.json"

NGX_CONF="/etc/nginx/nginx.conf"
NGX_DIR="/etc/nginx/conf.d/backendmgr"
SERVERS_DIR="${NGX_DIR}/servers"
NGX_BACKENDS_MAP="${NGX_DIR}/backends.map"
NGX_APPLY_SNIP="${NGX_DIR}/apply.conf"
NGX_MAIN_INCLUDE="${NGX_DIR}/backendmgr.conf"

# backups en /etc/nginx (misma ubicaciÃ³n)
BACKUP_DIR="/etc/nginx/backendmgr-backups"

NC='\033[0m'
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
CYA='\033[0;36m'
WHT='\033[1;37m'
DIM='\033[2m'

need_root() { [[ ${EUID:-999} -eq 0 ]] || { echo -e "${RED}ERROR:${NC} ejecutÃ¡: sudo nginx"; exit 1; }; }
pause() { echo; read -r -p "Enter para volver al menÃº..." _; }

read_cfg() {
  HEADER_NAME="$(jq -r '.header_name' "$CFG_FILE")"
  PRIMARY_DOMAIN="$(jq -r '.primary_domain' "$CFG_FILE")"
  [[ "$PRIMARY_DOMAIN" == "null" ]] && PRIMARY_DOMAIN=""
  RL_ENABLED="$(jq -r '.rate_limit_enabled' "$CFG_FILE")"
  RL_RATE="$(jq -r '.rate_limit_rate' "$CFG_FILE")"
  RL_BURST="$(jq -r '.rate_limit_burst' "$CFG_FILE")"
  CONN_LIMIT="$(jq -r '.conn_limit' "$CFG_FILE")"
  CURL_TMO="$(jq -r '.curl_timeout_seconds' "$CFG_FILE")"
  WINDOW_SEC="$(jq -r '.traffic_window_seconds' "$CFG_FILE")"
  STATS_LOG="$(jq -r '.stats_log_path' "$CFG_FILE")"
  BAL_MODE="$(jq -r '.balance_mode' "$CFG_FILE")"
}

ensure_files() {
  mkdir -p "$SERVERS_DIR" "$BACKUP_DIR" /var/log/nginx
  [[ -f "$NGX_BACKENDS_MAP" ]] || : > "$NGX_BACKENDS_MAP"
  [[ -f "$NGX_APPLY_SNIP" ]] || : > "$NGX_APPLY_SNIP"
  chmod 700 "$BACKUP_DIR" || true
}

nginx_test_reload() {
  if ! timeout 10s nginx -t; then
    echo -e "${YLW}âš ï¸ nginx -t fallÃ³. No recargo.${NC}"
    return 0
  fi
  timeout 8s nginx -s reload >/dev/null 2>&1 || true
  return 0
}

banner() {
  clear || true
  echo -e "${CYA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${CYA}â•‘${NC}  ğŸš€ ${APP_NAME} v${APP_VER}                                     ${CYA}â•‘${NC}"
  echo -e "${CYA}â•‘${NC}  Dominio madre: ${WHT}${PRIMARY_DOMAIN:-"(no configurado)"}${NC} | Header: ${WHT}${HEADER_NAME}${NC} ${CYA}â•‘${NC}"
  echo -e "${CYA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo
}

backend_lines() { grep -E '^\s*"[A-Za-z0-9_.:-]+"\s+"http://' "$NGX_BACKENDS_MAP" 2>/dev/null || true; }
server_files() { ls -1 "${SERVERS_DIR}"/*.conf 2>/dev/null || true; }

validate_domain() { [[ "$1" =~ ^[A-Za-z0-9.-]{3,253}$ ]]; }
validate_key() { [[ "$1" =~ ^[A-Za-z0-9_.:-]{2,64}$ ]]; }
validate_ip() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }

# ---- helpers para seleccionar de lista ----
pick_domain() {
  mapfile -t files < <(server_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    echo -e "${YLW}No hay dominios madre creados.${NC}"
    return 1
  fi
  echo -e "${CYA}Elegir dominio madre:${NC}"
  local i=0
  for f in "${files[@]}"; do
    i=$((i+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
    printf "%-3s) %s\n" "$i" "$dom"
  done
  echo
  read -r -p "NÃºmero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#files[@]} )) || return 1
  PICKED_DOMAIN_FILE="${files[$((n-1))]}"
  PICKED_DOMAIN="$(grep -E '^\s*server_name\s+' "$PICKED_DOMAIN_FILE" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/' || true)"
  [[ -n "${PICKED_DOMAIN:-}" ]] || return 1
  return 0
}

pick_backend() {
  mapfile -t lines < <(backend_lines)
  if [[ "${#lines[@]}" -eq 0 ]]; then
    echo -e "${YLW}No hay backends cargados.${NC}"
    return 1
  fi
  echo -e "${CYA}Elegir backend:${NC}"
  local i=0
  for line in "${lines[@]}"; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-3s) %-20s -> %s:%s\n" "$i" "$key" "$ip" "$port"
  done
  echo
  read -r -p "NÃºmero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || return 1
  (( n>=1 && n<=${#lines[@]} )) || return 1
  line="${lines[$((n-1))]}"
  PICKED_BACKEND="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
  PICKED_BACKEND_URL="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
  [[ -n "${PICKED_BACKEND:-}" ]] || return 1
  return 0
}

# ---- Dominio madre / Server ----
create_server_for_domain() {
  local dom="$1"
  local file="${SERVERS_DIR}/${dom}.conf"
  local safe="${dom//./_}"

  # valores por defecto como tu config
  local cto="${2:-300s}"
  local sto="${3:-600s}"
  local rto="${4:-600s}"

  cat > "$file" <<EOF
server {
    listen 80;
    listen [::]:80;

    server_name ${dom};

    access_log /var/log/nginx/${safe}.access.log;
    error_log  /var/log/nginx/${safe}.error.log;

    # Opcional: timeouts largos para backend
    proxy_connect_timeout ${cto};
    proxy_send_timeout    ${sto};
    proxy_read_timeout    ${rto};

    location / {
        proxy_pass \$backend_url;

        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        include /etc/nginx/conf.d/backendmgr/apply.conf;
    }
}
EOF
}

create_or_edit_server_http() {
  echo -e "${CYA}Crear/Editar dominio madre (server)${NC}"
  echo -e "${DIM}Este server recibe en 80 y reenvÃ­a a \$backend_url segÃºn el header Backend.${NC}\n"

  local dom=""
  if [[ -n "${PRIMARY_DOMAIN:-}" ]]; then
    read -r -p "Dominio (Enter=${PRIMARY_DOMAIN}): " dom
    dom="${dom:-$PRIMARY_DOMAIN}"
  else
    read -r -p "Dominio (ej: cpu2.elnene.site): " dom
  fi

  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return 0; }

  read -r -p "proxy_connect_timeout (Enter=300s): " cto
  read -r -p "proxy_send_timeout    (Enter=600s): " sto
  read -r -p "proxy_read_timeout    (Enter=600s): " rto
  cto="${cto:-300s}"; sto="${sto:-600s}"; rto="${rto:-600s}"

  create_server_for_domain "$dom" "$cto" "$sto" "$rto"
  nginx_test_reload
  echo -e "${GRN}âœ… Dominio madre listo:${NC} ${dom} (80)"
  return 0
}

set_primary_domain() {
  echo -e "${CYA}Configurar dominio madre principal${NC}"
  read -r -p "Dominio (ej: cpu2.elnene.site): " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return 0; }
  jq --arg v "$dom" '.primary_domain=$v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
  read_cfg
  echo -e "${GRN}âœ… Guardado.${NC}"
  return 0
}

# âœ… NUEVO: OpciÃ³n 3 crea el dominio madre automÃ¡ticamente
add_domain_auto_create() {
  echo -e "${CYA}Agregar dominio madre (y CREAR server automÃ¡tico)${NC}"
  echo -e "${DIM}Ejemplo: cpu2.nenenet.site${NC}\n"
  read -r -p "Dominio madre nuevo: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio invÃ¡lido.${NC}"; return 0; }

  # crea server con defaults (tu config)
  create_server_for_domain "$dom" "300s" "600s" "600s"

  nginx_test_reload
  echo -e "${GRN}âœ… Dominio madre creado:${NC} ${dom} (80)"
  echo -e "${DIM}Tip: si querÃ©s cambiar timeouts, usÃ¡ la opciÃ³n 9.${NC}"
  return 0
}

# ---- Backends ----
add_backend() {
  echo -e "${CYA}Agregar backend (nombre + IP + puerto)${NC}"
  echo -e "${DIM}Ejemplo: svpnene38 -> 179.43.112.38:80${NC}\n"

  read -r -p "Nombre del backend (ej: svpnene38): " key
  validate_key "$key" || { echo -e "${RED}Nombre invÃ¡lido.${NC}"; return 0; }

  read -r -p "IP (ej: 179.43.112.38): " ip
  validate_ip "$ip" || { echo -e "${RED}IP invÃ¡lida.${NC}"; return 0; }

  read -r -p "Puerto (ej: 80): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto invÃ¡lido.${NC}"; return 0; }

  local url="http://${ip}:${port}"

  if grep -qE "^\s*\"${key}\"" "$NGX_BACKENDS_MAP"; then
    awk -v k="$key" -v url="$url" '{re="^[ \t]*\""k"\""; if($0~re){sub(/\"http:\\/\\/[^\\\"]+\"/, "\""url"\"")} print}' \
      "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
    echo -e "${GRN}âœ… Actualizado:${NC} $key -> $ip:$port"
  else
    printf "        \"%s\" \"%s\";\n" "$key" "$url" >> "$NGX_BACKENDS_MAP"
    echo -e "${GRN}âœ… Agregado:${NC} $key -> $ip:$port"
  fi

  nginx_test_reload
  return 0
}

list_backends() {
  echo -e "${CYA}Backends (backend / IP / puerto)${NC}\n"
  printf "%-4s %-22s %-18s %-6s\n" "#" "BACKEND" "IP" "PORT"
  echo "--------------------------------------------------------------"
  local i=0
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-4s %-22s %-18s %-6s\n" "$i" "$key" "$ip" "$port"
  done < <(backend_lines)
  [[ "$i" -eq 0 ]] && echo -e "${YLW}No hay backends cargados.${NC}"
  return 0
}

list_domains() {
  echo -e "${CYA}Dominios madre (servers)${NC}\n"
  mapfile -t files < <(server_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    echo -e "${YLW}No hay dominios creados.${NC}"
    return 0
  fi
  local idx=0
  for f in "${files[@]}"; do
    idx=$((idx+1))
    dom="$(grep -E '^\s*server_name\s+' "$f" | head -n1 | sed -E 's/^\s*server_name\s+([^;]+);.*/\1/')"
    echo "$idx) $dom"
  done
  return 0
}

delete_backend_pick() {
  echo -e "${CYA}Eliminar backend${NC}\n"
  mapfile -t lines < <(backend_lines)
  [[ "${#lines[@]}" -eq 0 ]] && { echo -e "${YLW}No hay backends.${NC}"; return 0; }

  local i=0
  for line in "${lines[@]}"; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    printf "%-3s) %-22s -> %s:%s\n" "$i" "$key" "$ip" "$port"
  done

  read -r -p "NÃºmero: " n
  [[ "$n" =~ ^[0-9]+$ ]] || { echo -e "${RED}InvÃ¡lido.${NC}"; return 0; }
  (( n>=1 && n<=${#lines[@]} )) || { echo -e "${RED}Fuera de rango.${NC}"; return 0; }

  target="${lines[$((n-1))]}"
  awk -v t="$target" '$0!=t{print}' "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" || true
  mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
  nginx_test_reload
  echo -e "${GRN}âœ… Eliminado.${NC}"
  return 0
}

healthcheck_all() {
  echo -e "${CYA}Healthcheck (HTTP y latencia)${NC}"
  echo -e "${DIM}HTTP 000 = no responde â€¢ timeout curl: ${CURL_TMO}s${NC}\n"
  printf "%-22s %-18s %-6s %-6s %-10s\n" "BACKEND" "IP" "PORT" "HTTP" "LAT(ms)"
  echo "------------------------------------------------------------------"
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"; ip="${ipport%%:*}"; port="${ipport##*:}"
    out="$(curl -m "$CURL_TMO" -s -o /dev/null -w "%{http_code} %{time_total}" "${url}/" || echo "000 9.999")"
    code="$(echo "$out" | awk '{print $1}')"
    t="$(echo "$out" | awk '{print $2}')"
    ms="$(awk -v x="$t" 'BEGIN{printf "%.0f", x*1000}')"
    printf "%-22s %-18s %-6s %-6s %-10s\n" "$key" "$ip" "$port" "$code" "$ms"
  done < <(backend_lines)
  return 0
}

# âœ… NUEVO: Validar que el dominio madre + header engancha al backend correcto
validate_connection_test() {
  echo -e "${CYA}Validar conexiÃ³n (dominio madre â†’ backend por header)${NC}"
  echo -e "${DIM}Hace un curl desde el VPS: http://DOMINIO/ con header ${HEADER_NAME}: backend${NC}\n"

  if ! pick_domain; then
    echo -e "${YLW}No pude seleccionar dominio.${NC}"
    return 0
  fi
  if ! pick_backend; then
    echo -e "${YLW}No pude seleccionar backend.${NC}"
    return 0
  fi

  echo
  echo -e "${WHT}Probando:${NC}"
  echo "  Dominio : ${PICKED_DOMAIN}"
  echo "  Header  : ${HEADER_NAME}: ${PICKED_BACKEND}"
  echo "  Backend : ${PICKED_BACKEND_URL}"
  echo

  # 1) Probar que el dominio responde
  echo -e "${DIM}1) Dominio responde:${NC}"
  out1="$(curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" "http://${PICKED_DOMAIN}/" || true)"
  echo "$out1"
  echo

  # 2) Probar con header (esto fuerza map $http_backend)
  echo -e "${DIM}2) Dominio + header (selecciÃ³n de backend):${NC}"
  out2="$(curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" -H "${HEADER_NAME}: ${PICKED_BACKEND}" "http://${PICKED_DOMAIN}/" || true)"
  echo "$out2"
  echo

  # 3) Probar backend directo (para comparar)
  echo -e "${DIM}3) Backend directo (comparaciÃ³n):${NC}"
  out3="$(curl -m "$CURL_TMO" -s -o /dev/null -w "HTTP=%{http_code} TIME=%{time_total}s\n" "${PICKED_BACKEND_URL}/" || true)"
  echo "$out3"
  echo

  echo -e "${GRN}âœ… Si (2) y (3) se parecen y no te da 000, el enrutado estÃ¡ funcionando.${NC}"
  echo -e "${DIM}Tip: si (1) falla, el dominio no resuelve al VPS o el puerto 80 estÃ¡ cerrado.${NC}"
  return 0
}

backup_bundle() {
  mkdir -p "$BACKUP_DIR"
  local out="${BACKUP_DIR}/bundle-$(date +%Y%m%d-%H%M%S).tar.gz"
  tar -czf "$out" \
    /etc/nginx/nginx.conf \
    /etc/nginx/conf.d/backendmgr \
    /etc/backendmgr \
    /var/lib/backendmgr 2>/dev/null || true
  echo -e "${GRN}âœ… Backup creado:${NC} $out"
  return 0
}

restore_bundle() {
  echo -e "${CYA}Restaurar backup${NC}"
  ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | nl -w2 -s') ' || { echo "No hay backups."; return 0; }
  read -r -p "NÃºmero: " n
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | sed -n "${n}p")"
  [[ -n "${file:-}" ]] || { echo -e "${YLW}SelecciÃ³n invÃ¡lida.${NC}"; return 0; }

  echo -e "${YLW}âš ï¸ Backup preventivo antes de restaurar...${NC}"
  backup_bundle
  tar -xzf "$file" -C / 2>/dev/null || true
  nginx_test_reload
  echo -e "${GRN}âœ… Restaurado.${NC}"
  return 0
}

# Servicios Nginx juntos
nginx_services_menu() {
  echo -e "${CYA}Servicios Nginx${NC}"
  echo " 1) Status"
  echo " 2) Stop (detener)"
  echo " 3) Start (reanudar)"
  echo " 4) Reload (recargar config)"
  echo " 5) Restart (reiniciar)"
  echo " 0) Volver"
  read -r -p "OpciÃ³n: " op
  echo
  case "$op" in
    1)
      if command -v systemctl >/dev/null 2>&1; then
        systemctl status nginx --no-pager || true
      else
        ps aux | grep -E '[n]ginx' || true
      fi
      ;;
    2)
      if command -v systemctl >/dev/null 2>&1; then
        systemctl stop nginx || true
      else
        timeout 5s nginx -s quit >/dev/null 2>&1 || true
      fi
      echo -e "${GRN}âœ… Stop OK.${NC}"
      ;;
    3)
      if command -v systemctl >/dev/null 2>&1; then
        systemctl start nginx || true
      else
        nginx >/dev/null 2>&1 || true
      fi
      echo -e "${GRN}âœ… Start OK.${NC}"
      ;;
    4)
      nginx_test_reload
      echo -e "${GRN}âœ… Reload OK.${NC}"
      ;;
    5)
      if command -v systemctl >/dev/null 2>&1; then
        systemctl restart nginx || true
      else
        timeout 5s nginx -s quit >/dev/null 2>&1 || true
        nginx >/dev/null 2>&1 || true
      fi
      echo -e "${GRN}âœ… Restart OK.${NC}"
      ;;
    0) return 0 ;;
    *) echo "OpciÃ³n invÃ¡lida" ;;
  esac
  return 0
}

menu() {
  echo -e "${WHT}ğŸ“Œ MENÃš PRINCIPAL${NC}"
  echo "  1) ğŸŒ Configurar dominio madre principal"
  echo "  2) â• Agregar backend (nombre + IP + puerto)"
  echo "  3) ğŸŒ Agregar dominio madre (AUTO crea server)"
  echo "  4) ğŸ“„ Listar backends (backend / IP / puerto)"
  echo "  5) ğŸŒ Listar dominios madre (servers)"
  echo "  6) ğŸ—‘ï¸  Eliminar backend"
  echo "  7) âœ… Healthcheck (HTTP y latencia)"
  echo "  8) ğŸ§ª Validar conexiÃ³n (dominio â†’ backend por header)"
  echo "  9) ğŸ§© Crear/Editar dominio madre (server) + timeouts"
  echo " 14) ğŸ’¾ Backup"
  echo " 15) â™»ï¸  Restaurar backup"
  echo " 16) âš™ï¸  Servicios de Nginx (Status/Stop/Start/Reload/Restart)"
  echo "  0) ğŸšª Salir"
  echo
}

main() {
  need_root
  read_cfg
  ensure_files

  while true; do
    banner
    menu
    read -r -p "OpciÃ³n: " opt
    echo
    case "$opt" in
      1) set_primary_domain; pause ;;
      2) add_backend; pause ;;
      3) add_domain_auto_create; pause ;;
      4) list_backends; pause ;;
      5) list_domains; pause ;;
      6) delete_backend_pick; pause ;;
      7) healthcheck_all; pause ;;
      8) validate_connection_test; pause ;;
      9) create_or_edit_server_http; pause ;;
      14) backup_bundle; pause ;;
      15) restore_bundle; pause ;;
      16) nginx_services_menu; pause ;;
      0) exit 0 ;;
      *) echo -e "${YLW}OpciÃ³n invÃ¡lida.${NC}"; pause ;;
    esac
  done
}

main
