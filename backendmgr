#!/usr/bin/env bash
set -euo pipefail

APP_NAME="Backend Manager Nenenet 3.0"
APP_VER="3.3"

CFG_FILE="/etc/backendmgr/config.json"
BACKUP_DIR="/root/backendmgr-backups"

NGX_DIR="/etc/nginx/conf.d/backendmgr"
NGX_MAIN_INCLUDE="${NGX_DIR}/backendmgr.conf"
NGX_BACKENDS_MAP="${NGX_DIR}/backends.map"
NGX_LOGGING_SNIP="${NGX_DIR}/logging.conf"
NGX_APPLY_SNIP="${NGX_DIR}/apply.conf"

NGX_BALANCER_CONF="${NGX_DIR}/balancer.conf"
NGX_BALANCED_MAP="${NGX_DIR}/balanced.map"
NGX_LIMITS_IP="${NGX_DIR}/limits_ip.map"
NGX_LIMITS_BACKEND="${NGX_DIR}/limits_backend.map"
NGX_LIMITS_URL="${NGX_DIR}/limits_url.map"

SERVERS_DIR="${NGX_DIR}/servers"

NC='\033[0m'
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
CYA='\033[0;36m'
WHT='\033[1;37m'
DIM='\033[2m'

need_root() { [[ ${EUID:-999} -eq 0 ]] || { echo -e "${RED}ERROR:${NC} ejecut√°: sudo nginx"; exit 1; }; }
pause() { echo; read -r -p "Enter para continuar..." _; }
die() { echo -e "${RED}ERROR:${NC} $*"; exit 1; }

nginx_test_reload() { nginx -t && systemctl reload nginx; }
nginx_active() { systemctl is-active --quiet nginx && echo "ACTIVO" || echo "INACTIVO"; }

read_cfg() {
  [[ -f "$CFG_FILE" ]] || die "Falta $CFG_FILE. Instal√° con install.sh"
  HEADER_NAME="$(jq -r '.header_name' "$CFG_FILE")"
  PRIMARY_DOMAIN="$(jq -r '.primary_domain' "$CFG_FILE")"
  [[ "$PRIMARY_DOMAIN" == "null" ]] && PRIMARY_DOMAIN=""

  RL_ENABLED="$(jq -r '.rate_limit_enabled' "$CFG_FILE")"
  RL_RATE="$(jq -r '.rate_limit_rate' "$CFG_FILE")"
  RL_BURST="$(jq -r '.rate_limit_burst' "$CFG_FILE")"
  CONN_LIMIT="$(jq -r '.conn_limit' "$CFG_FILE")"

  CURL_TMO="$(jq -r '.curl_timeout_seconds' "$CFG_FILE")"
  WINDOW_SEC="$(jq -r '.traffic_window_seconds' "$CFG_FILE")"
  STATS_LOG="$(jq -r '.stats_log_path' "$CFG_FILE")"

  BAL_MODE="$(jq -r '.balance_mode' "$CFG_FILE")"
  BAL_CAP="$(jq -r '.balance_max_slots_cap' "$CFG_FILE")"
}

ensure_files() {
  mkdir -p "$NGX_DIR" "$SERVERS_DIR" "/var/lib/backendmgr" "$BACKUP_DIR"
  chmod 700 "$BACKUP_DIR" || true

  for f in "$NGX_MAIN_INCLUDE" "$NGX_BACKENDS_MAP" "$NGX_LOGGING_SNIP" "$NGX_APPLY_SNIP" \
           "$NGX_BALANCER_CONF" "$NGX_BALANCED_MAP" "$NGX_LIMITS_IP" "$NGX_LIMITS_BACKEND" "$NGX_LIMITS_URL"
  do
    [[ -f "$f" ]] || : > "$f"
  done
}

banner() {
  clear
  echo -e "${CYA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${CYA}‚ïë${NC}  üöÄ ${APP_NAME}  v${APP_VER}                                   ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïë${NC}  Dominio madre principal: ${WHT}${PRIMARY_DOMAIN:-"(no configurado)"}${NC} | Header: ${WHT}${HEADER_NAME}${NC} ${CYA}‚ïë${NC}"
  echo -e "${CYA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo
}

quick_status() {
  echo -e "${WHT}üìä ESTADO${NC}"
  echo -e "   üß© Nginx: ${GRN}$(nginx_active)${NC}"
  echo -e "   üåê Dominio madre principal: ${GRN}${PRIMARY_DOMAIN:-"(no configurado)"}${NC}"
  echo -e "   ‚öñÔ∏è Balance: ${GRN}${BAL_MODE}${NC}"
  echo -e "   üõ°Ô∏è Rate limit (Rate limiting): ${GRN}${RL_ENABLED}${NC} (${RL_RATE}, burst ${RL_BURST}, conn ${CONN_LIMIT})"
  echo -e "   üìà Stats log: ${DIM}${STATS_LOG}${NC}"
  echo
}

# ---------- Validaciones ----------
validate_domain() { [[ "$1" =~ ^[A-Za-z0-9.-]{3,253}$ ]]; }
validate_key() { [[ "$1" =~ ^[A-Za-z0-9_.:-]{2,64}$ ]]; }
validate_ip() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }
validate_rate() { [[ "$1" == "0" || "$1" =~ ^[0-9]+[kKmM]$ ]]; }

# ---------- Helpers de backends ----------
backend_lines() {
  grep -E '^\s*"[A-Za-z0-9_.:-]+"\s+"http://' "$NGX_BACKENDS_MAP" 2>/dev/null || true
}

# ---------- Opci√≥n 1: dominio madre principal ----------
set_primary_domain() {
  echo -e "${CYA}Configurar dominio madre principal${NC}"
  echo -e "${DIM}Ejemplo: cpu2.elnene.site${NC}"
  read -r -p "Dominio madre principal: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }

  jq --arg v "$dom" '.primary_domain = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
  read_cfg

  echo -e "${GRN}‚úÖ Guardado. Ahora pod√©s crear/editar su server con la opci√≥n 9.${NC}"
}

# ---------- Opci√≥n 2: agregar backend ----------
add_backend() {
  echo -e "${CYA}Agregar backend (nombre + IP + puerto)${NC}"
  echo -e "${DIM}Ejemplo: backend=svpnene38 | IP=179.43.112.38 | Puerto=80${NC}"
  echo

  read -r -p "Nombre del backend (ej: svpnene38): " key
  validate_key "$key" || { echo -e "${RED}Nombre backend inv√°lido.${NC}"; return; }

  read -r -p "IP (ej: 179.43.112.38): " ip
  validate_ip "$ip" || { echo -e "${RED}IP inv√°lida.${NC}"; return; }

  read -r -p "Puerto (ej: 80): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return; }

  url="http://${ip}:${port}"

  if grep -qE "^\s*\"${key}\"" "$NGX_BACKENDS_MAP"; then
    awk -v k="$key" -v url="$url" '{ re="^[ \t]*\""k"\""; if($0 ~ re){ sub(/"http:\/\/[^"]+"/, "\""url"\"") } print }' \
      "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"
    echo -e "${GRN}‚úÖ Backend actualizado:${NC} ${key} -> ${ip}:${port}"
  else
    printf "    \"%s\" \"%s\";\n" "$key" "$url" >> "$NGX_BACKENDS_MAP"
    echo -e "${GRN}‚úÖ Backend agregado:${NC} ${key} -> ${ip}:${port}"
  fi

  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true
  nginx_test_reload
}

# ---------- Opci√≥n 3: otro dominio ----------
add_other_domain() {
  echo -e "${CYA}Agregar otro dominio madre${NC}"
  echo -e "${DIM}Ejemplo: cpu2.nenenet.site${NC}"
  read -r -p "Dominio madre nuevo: " dom
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }
  echo -e "${GRN}‚úÖ Listo. Ahora cre√°/editalo con la opci√≥n 9 o clonalo con la opci√≥n 10.${NC}"
}

# ---------- Opci√≥n 4: listar backends ----------
list_backends_general() {
  echo -e "${CYA}Lista general de backends (nombre / IP / puerto)${NC}"
  echo
  printf "%-4s %-18s %-18s %-6s\n" "#" "BACKEND" "IP" "PORT"
  echo "----------------------------------------------------------"

  i=0
  backend_lines | while read -r line; do
    i=$((i+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"
    ip="${ipport%%:*}"
    port="${ipport##*:}"
    printf "%-4s %-18s %-18s %-6s\n" "$i" "$key" "$ip" "$port"
  done

  echo
  echo -e "${DIM}Tip: Para que stats/limits/balance se apliquen, en tu location / debe estar:${NC}"
  echo -e "${DIM}     include /etc/nginx/conf.d/backendmgr/apply.conf;${NC}"
}

# ---------- Opci√≥n 6: eliminar backend ----------
delete_backend_pick() {
  echo -e "${CYA}Eliminar backend (elegir de lista)${NC}"
  echo

  mapfile -t lines < <(backend_lines)
  if [[ "${#lines[@]}" -eq 0 ]]; then
    echo -e "${YLW}No hay backends cargados.${NC}"
    return
  fi

  idx=0
  for line in "${lines[@]}"; do
    idx=$((idx+1))
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"
    ip="${ipport%%:*}"
    port="${ipport##*:}"
    printf "%-3s) %-18s -> %s:%s\n" "$idx" "$key" "$ip" "$port"
  done

  echo
  read -r -p "N√∫mero a eliminar: " n
  [[ "$n" =~ ^[0-9]+$ ]] || { echo -e "${RED}N√∫mero inv√°lido.${NC}"; return; }
  (( n>=1 && n<=${#lines[@]} )) || { echo -e "${RED}Fuera de rango.${NC}"; return; }

  target="${lines[$((n-1))]}"
  grep -vF "$target" "$NGX_BACKENDS_MAP" > "${NGX_BACKENDS_MAP}.tmp" && mv "${NGX_BACKENDS_MAP}.tmp" "$NGX_BACKENDS_MAP"

  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Backend eliminado.${NC}"
}

# ---------- Healthcheck ----------
healthcheck_all() {
  echo -e "${CYA}Healthcheck (¬ølos backends responden? + latencia)${NC}"
  echo -e "${DIM}‚Ä¢ HTTP: c√≥digo (200/301/403/500/etc). ‚Ä¢ LAT(ms): milisegundos. ‚Ä¢ 000 = no responde/timeout.${NC}"
  echo -e "${DIM}Timeout curl: ${CURL_TMO}s${NC}"
  echo

  printf "%-18s %-18s %-6s %-8s %-10s\n" "BACKEND" "IP" "PORT" "HTTP" "LAT(ms)"
  echo "---------------------------------------------------------------------"

  backend_lines | while read -r line; do
    key="$(echo "$line" | sed -E 's/^\s*"([^"]+)".*$/\1/')"
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    ipport="${url#http://}"
    ip="${ipport%%:*}"
    port="${ipport##*:}"

    out="$(curl -m "$CURL_TMO" -s -o /dev/null -w "%{http_code} %{time_total}" "${url}/" || echo "000 9.999")"
    code="$(echo "$out" | awk '{print $1}')"
    t="$(echo "$out" | awk '{print $2}')"
    ms="$(awk -v x="$t" 'BEGIN{printf "%.0f", x*1000}')"

    printf "%-18s %-18s %-6s %-8s %-10s\n" "$key" "$ip" "$port" "$code" "$ms"
  done
}

# ---------- Rate limit ----------
rewrite_rate_zone() {
  if grep -qE '^\s*limit_req_zone\s+\$binary_remote_addr\s+zone=backendmgr_req:10m\s+rate=' "$NGX_MAIN_INCLUDE"; then
    awk -v rate="$RL_RATE" '
      { if($0 ~ /^\s*limit_req_zone\s+\$binary_remote_addr\s+zone=backendmgr_req:10m\s+rate=/){ sub(/rate=[^;]+;/, "rate="rate";") } print }
    ' "$NGX_MAIN_INCLUDE" > "${NGX_MAIN_INCLUDE}.tmp" && mv "${NGX_MAIN_INCLUDE}.tmp" "$NGX_MAIN_INCLUDE"
  fi
}

rate_limit_menu() {
  echo -e "${CYA}Rate limit (Rate limiting) - protecci√≥n b√°sica en Nginx${NC}"
  echo -e "${DIM}Limita requests por IP y conexiones simult√°neas (anti-abuso).${NC}"
  echo
  echo "Estado:     $RL_ENABLED"
  echo "Rate:       $RL_RATE     (requests/seg por IP)"
  echo "Burst:      $RL_BURST    (r√°faga permitida)"
  echo "Conn limit: $CONN_LIMIT  (conexiones simult√°neas por IP)"
  echo
  echo "1) Activar / Desactivar"
  echo "2) Cambiar rate (ej: 10r/s)"
  echo "3) Cambiar burst"
  echo "4) Cambiar conn limit"
  echo "5) Aplicar ahora"
  read -r -p "Opci√≥n: " op

  case "$op" in
    1)
      if [[ "$RL_ENABLED" == "true" ]]; then RL_ENABLED="false"; else RL_ENABLED="true"; fi
      jq ".rate_limit_enabled = ${RL_ENABLED}" "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      read_cfg
      ;;
    2)
      read -r -p "Nuevo rate (ej: 10r/s): " v
      [[ "$v" =~ ^[0-9]+r/s$ ]] || { echo -e "${RED}Formato inv√°lido (ej: 10r/s).${NC}"; return; }
      jq --arg v "$v" '.rate_limit_rate = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      read_cfg
      ;;
    3)
      read -r -p "Nuevo burst (n√∫mero): " v
      [[ "$v" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return; }
      jq --argjson v "$v" '.rate_limit_burst = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      read_cfg
      ;;
    4)
      read -r -p "Nuevo conn limit (n√∫mero): " v
      [[ "$v" =~ ^[0-9]+$ ]] || { echo -e "${RED}Inv√°lido.${NC}"; return; }
      jq --argjson v "$v" '.conn_limit = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
      read_cfg
      ;;
    5)
      read_cfg
      rewrite_rate_zone
      write_apply_conf
      nginx_test_reload
      echo -e "${GRN}‚úÖ Aplicado.${NC}"
      ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ---------- Balanceador ----------
rebuild_balancer_files() {
  read_cfg
  cap="$BAL_CAP"
  [[ "$cap" =~ ^[0-9]+$ ]] || cap=64

  : > "$NGX_BALANCED_MAP"
  i=0
  while read -r line; do
    url="$(echo "$line" | sed -E 's/^.*"\s+"([^"]+)";\s*$/\1/')"
    printf "    \"%s\" \"%s\";\n" "$i" "$url" >> "$NGX_BALANCED_MAP"
    i=$((i+1))
    [[ $i -ge $cap ]] && break
  done < <(backend_lines)

  if [[ $i -lt 2 ]]; then
    cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (balance OFF)
map $host $backendmgr_balance { default 0; }
map $host $backendmgr_slot { default "0"; }
map $backendmgr_slot $balanced_backend_url {
    default $backend_url;
    include /etc/nginx/conf.d/backendmgr/balanced.map;
}
EOF
    return 0
  fi

  if [[ "$BAL_MODE" == "off" ]]; then
    cat > "$NGX_BALANCER_CONF" <<'EOF'
# backendmgr balancer.conf (balance OFF)
map $host $backendmgr_balance { default 0; }
map $host $backendmgr_slot { default "0"; }
map $backendmgr_slot $balanced_backend_url {
    default $backend_url;
    include /etc/nginx/conf.d/backendmgr/balanced.map;
}
EOF
    return 0
  fi

  base=$((100 / i))
  rem=$((100 - base * i))

  split_key='$remote_addr'
  [[ "$BAL_MODE" == "random" ]] && split_key='$remote_addr$msec$connection'

  {
    echo "# backendmgr balancer.conf (balance: ${BAL_MODE})"
    echo "map \$host \$backendmgr_balance { default 1; }"
    echo "split_clients \"${split_key}\" \$backendmgr_slot {"
    for ((n=0;n<i;n++)); do
      pct="$base"
      if (( rem > 0 )); then pct=$((pct+1)); rem=$((rem-1)); fi
      echo "    ${pct}% \"${n}\";"
    done
    echo "}"
    echo "map \$backendmgr_slot \$balanced_backend_url {"
    echo "    default \$backend_url;"
    echo "    include ${NGX_BALANCED_MAP};"
    echo "}"
  } > "$NGX_BALANCER_CONF"
}

set_balance_mode() {
  echo -e "${CYA}Balanceador (Load balancing) - equilibrar tr√°fico entre backends${NC}"
  echo -e "${DIM}‚Ä¢ OFF: usa header Backend (tu modo actual). ‚Ä¢ RANDOM: reparte por request. ‚Ä¢ STICKY-IP: por IP.${NC}"
  echo
  echo "1) OFF"
  echo "2) RANDOM"
  echo "3) STICKY-IP (iphash)"
  read -r -p "Opci√≥n: " op
  case "$op" in
    1) BAL_MODE="off" ;;
    2) BAL_MODE="random" ;;
    3) BAL_MODE="iphash" ;;
    *) echo "Inv√°lida"; return ;;
  esac
  jq --arg v "$BAL_MODE" '.balance_mode = $v' "$CFG_FILE" > "${CFG_FILE}.tmp" && mv "${CFG_FILE}.tmp" "$CFG_FILE"
  read_cfg
  rebuild_balancer_files
  write_apply_conf
  nginx_test_reload
  echo -e "${GRN}‚úÖ Balance: ${BAL_MODE}${NC}"
}

# ---------- apply.conf ----------
write_apply_conf() {
  read_cfg
  rewrite_rate_zone >/dev/null 2>&1 || true

  cat > "$NGX_APPLY_SNIP" <<EOF_APPLY
# ${APP_NAME} apply.conf
# Incluir dentro de location / :
# include /etc/nginx/conf.d/backendmgr/apply.conf;

# Stats log
access_log ${STATS_LOG} backendmgr_stats;

# Balance: si est√° activo, pisa backend_url por el balanceado
if (\$backendmgr_balance = 1) {
    set \$backend_url \$balanced_backend_url;
}

EOF_APPLY

  if [[ "$RL_ENABLED" == "true" ]]; then
    cat >> "$NGX_APPLY_SNIP" <<EOF_RL
limit_req zone=backendmgr_req burst=${RL_BURST} nodelay;
limit_conn backendmgr_conn ${CONN_LIMIT};

EOF_RL
  else
    cat >> "$NGX_APPLY_SNIP" <<'EOF_OFF'
# rate-limit desactivado
EOF_OFF
  fi

  cat >> "$NGX_APPLY_SNIP" <<'EOF_LIMITS'
# Speed limits (0 = unlimited)
# prioridad: Backend(key) > URL(actual) > IP
set $nenenet_rate 0;

if ($backend_limit_rate != 0) { set $nenenet_rate $backend_limit_rate; }
if ($nenenet_rate = 0) { if ($url_limit_rate != 0) { set $nenenet_rate $url_limit_rate; } }
if ($nenenet_rate = 0) { if ($ip_limit_rate != 0) { set $nenenet_rate $ip_limit_rate; } }

limit_rate $nenenet_rate;
EOF_LIMITS
}

# ---------- Server template editar + timeouts ----------
get_current_timeout() {
  local file="$1" key="$2" def="$3"
  local v
  if [[ -f "$file" ]]; then
    v="$(grep -E "^\s*${key}\s+" "$file" 2>/dev/null | head -n1 | awk '{print $2}' | tr -d ';' || true)"
    [[ -n "${v:-}" ]] && { echo "$v"; return; }
  fi
  echo "$def"
}

server_template_edit() {
  echo -e "${CYA}Configurar / Editar server Nginx (dominio madre) + timeouts${NC}"
  echo -e "${DIM}Enter = dejar el valor actual/por defecto.${NC}"
  echo

  if [[ -z "${PRIMARY_DOMAIN:-}" ]]; then
    echo -e "${YLW}Primero configur√° el dominio madre principal con la opci√≥n 1.${NC}"
    return
  fi

  read -r -p "Dominio (Enter = ${PRIMARY_DOMAIN}): " dom
  dom="${dom:-$PRIMARY_DOMAIN}"
  validate_domain "$dom" || { echo -e "${RED}Dominio inv√°lido.${NC}"; return; }

  local file="${SERVERS_DIR}/${dom}.conf"

  local cur_connect cur_send cur_read
  cur_connect="$(get_current_timeout "$file" "proxy_connect_timeout" "300s")"
  cur_send="$(get_current_timeout "$file" "proxy_send_timeout" "600s")"
  cur_read="$(get_current_timeout "$file" "proxy_read_timeout" "600s")"

  read -r -p "proxy_connect_timeout (Enter=${cur_connect}): " v1
  read -r -p "proxy_send_timeout    (Enter=${cur_send}): " v2
  read -r -p "proxy_read_timeout    (Enter=${cur_read}): " v3

  v1="${v1:-$cur_connect}"
  v2="${v2:-$cur_send}"
  v3="${v3:-$cur_read}"

  local safe="${dom//./_}"
  local access="/var/log/nginx/${safe}.access.log"
  local error="/var/log/nginx/${safe}.error.log"

  cat > "$file" <<EOF
server {
    listen 80;
    listen [::]:80;

    server_name ${dom};

    access_log ${access};
    error_log  ${error};

    # Opcional: timeouts largos para backend (Enter = default)
    proxy_connect_timeout ${v1};
    proxy_send_timeout    ${v2};
    proxy_read_timeout    ${v3};

    location / {
        proxy_pass \$backend_url;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        include /etc/nginx/conf.d/backendmgr/apply.conf;
    }
}
EOF

  nginx_test_reload
  echo -e "${GRN}‚úÖ Server actualizado:${NC} ${file}"
}

# ---------- NUEVO: Clonar server ----------
server_template_clone() {
  echo -e "${CYA}Clonar server (copiar config de un dominio a otro)${NC}"
  echo -e "${DIM}√ötil para no reescribir timeouts / headers / estructura.${NC}"
  echo

  if [[ -z "${PRIMARY_DOMAIN:-}" ]]; then
    echo -e "${YLW}Primero configur√° el dominio madre principal con la opci√≥n 1.${NC}"
    return
  fi

  read -r -p "Dominio ORIGEN (Enter=${PRIMARY_DOMAIN}): " src
  src="${src:-$PRIMARY_DOMAIN}"
  validate_domain "$src" || { echo -e "${RED}Dominio origen inv√°lido.${NC}"; return; }

  read -r -p "Dominio DESTINO (ej: cpu2.nenenet.site): " dst
  validate_domain "$dst" || { echo -e "${RED}Dominio destino inv√°lido.${NC}"; return; }
  [[ "$src" != "$dst" ]] || { echo -e "${RED}Origen y destino no pueden ser iguales.${NC}"; return; }

  local srcf="${SERVERS_DIR}/${src}.conf"
  local dstf="${SERVERS_DIR}/${dst}.conf"

  [[ -f "$srcf" ]] || {
    echo -e "${YLW}No existe el server origen:${NC} $srcf"
    echo -e "${DIM}Crealo primero con la opci√≥n 9.${NC}"
    return
  }

  cp -f "$srcf" "$dstf"

  local safe="${dst//./_}"
  local access="/var/log/nginx/${safe}.access.log"
  local error="/var/log/nginx/${safe}.error.log"

  sed -i -E "s/^\s*server_name\s+[^;]+;/    server_name ${dst};/g" "$dstf"
  sed -i -E "s|^\s*access_log\s+[^;]+;|    access_log ${access};|g" "$dstf"
  sed -i -E "s|^\s*error_log\s+[^;]+;|    error_log  ${error};|g" "$dstf"

  nginx_test_reload
  echo -e "${GRN}‚úÖ Clonado:${NC} ${src} -> ${dst}"
  echo -e "${DIM}Archivo:${NC} ${dstf}"
}

# ---------- Tr√°fico por IP ----------
traffic_by_ip() {
  echo -e "${CYA}Tr√°fico por IP (√∫ltimos ${WINDOW_SEC}s)${NC}"
  [[ -f "$STATS_LOG" ]] || { echo -e "${YLW}No existe stats log:${NC} $STATS_LOG"; return; }
  local now cut
  now="$(date +%s)"; cut=$((now - WINDOW_SEC))
  tail -n 20000 "$STATS_LOG" | gawk -F'\\|' -v cut="$cut" '
    function mon(m){ return index("JanFebMarAprMayJunJulAugSepOctNovDec", m)/3 }
    function toEpoch(t,   d,mo,y,h,mi,s){
      split(t,a,"[:/ ]"); d=a[1]; mo=mon(a[2]); y=a[3]; h=a[4]; mi=a[5]; s=a[6]
      return mktime(y" "mo" "d" "h" "mi" "s)
    }
    { e=toEpoch($1); ip=$2; bytes=$6+0; if(e>=cut){ sum[ip]+=bytes } }
    END{ for(ip in sum) printf "%s\t%.0f\n", ip, sum[ip] }
  ' | sort -k2 -nr | head -n 25
}

traffic_menu() {
  echo -e "${CYA}Tr√°fico${NC}"
  echo "1) Por IP"
  read -r -p "Opci√≥n: " op
  case "$op" in
    1) traffic_by_ip ;;
    *) echo "Opci√≥n inv√°lida" ;;
  esac
}

# ---------- Firewall UFW ----------
ufw_open_port() {
  echo -e "${CYA}Firewall UFW: permitir tr√°fico por puerto${NC}"
  echo -e "${DIM}Ejemplo: permitir 80/tcp (HTTP) o 443/tcp (HTTPS).${NC}"
  echo

  command -v ufw >/dev/null 2>&1 || { echo -e "${YLW}UFW no est√° instalado. Instalalo con: apt install -y ufw${NC}"; return; }

  echo -e "${WHT}Estado actual:${NC}"
  ufw status || true
  echo

  read -r -p "Puerto a habilitar (ej: 80 o 443): " port
  [[ "$port" =~ ^[0-9]{2,5}$ ]] || { echo -e "${RED}Puerto inv√°lido.${NC}"; return; }

  echo
  echo -e "${DIM}Ejecutando:${NC} ufw allow ${port}/tcp"
  ufw allow "${port}/tcp" || true

  if [[ "$port" == "80" ]]; then
    ufw allow 'Nginx HTTP' || true
  fi
  if [[ "$port" == "443" ]]; then
    ufw allow 'Nginx Full' || true
  fi

  ufw reload || true
  echo -e "${GRN}‚úÖ Regla aplicada.${NC}"
  ufw status || true
}

# ---------- Backup/Restore ----------
backup_bundle() {
  mkdir -p "$BACKUP_DIR"
  local out="${BACKUP_DIR}/bundle-$(date +%Y%m%d-%H%M%S).tar.gz"
  tar -czf "$out" /etc/nginx /etc/backendmgr /var/lib/backendmgr 2>/dev/null || true
  echo -e "${GRN}‚úÖ Backup creado:${NC} $out"
}

restore_bundle() {
  echo -e "${CYA}Restaurar backup${NC}"
  ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | nl -w2 -s') ' || { echo "No hay backups."; return; }
  echo
  read -r -p "N√∫mero: " n
  local file
  file="$(ls -1t "${BACKUP_DIR}"/bundle-*.tar.gz 2>/dev/null | sed -n "${n}p")"
  [[ -n "${file:-}" ]] || { echo -e "${YLW}Selecci√≥n inv√°lida.${NC}"; return; }

  echo -e "${YLW}‚ö†Ô∏è Backup de seguridad antes de restaurar.${NC}"
  backup_bundle
  tar -xzf "$file" -C / 2>/dev/null || true
  nginx_test_reload
  echo -e "${GRN}‚úÖ Restaurado.${NC}"
}

# ---------- Men√∫ ----------
menu() {
  echo -e "${WHT}üìå MEN√ö PRINCIPAL${NC}"
  echo "  1) üåê Configurar dominio madre principal (ej: cpu2.elnene.site)"
  echo "  2) ‚ûï Agregar backend (ej: svpnene38 + IP + puerto)"
  echo "  3) üåê Agregar otro dominio madre (ej: cpu2.nenenet.site)"
  echo "  4) üìÑ Listar backends (general: nombre + IP + puerto)"
  echo "  5) (Reservado)"
  echo "  6) üóëÔ∏è  Eliminar backend (elegir de lista)"
  echo "  7) ‚úÖ Healthcheck (estado HTTP y latencia) (Backend healthcheck)"
  echo "  8) üõ°Ô∏è Rate limit (l√≠mite de requests/conexiones) (Rate limiting)"
  echo "  9) üß© Crear/Editar server Nginx del dominio + timeouts (Enter=default)"
  echo " 10) üìÑ Clonar server (copiar dominio origen -> dominio destino)"
  echo " 11) ‚öñÔ∏è Balanceador (equilibrar tr√°fico) (Load balancing)"
  echo " 12) üìä Tr√°fico (por IP)"
  echo " 13) üî• Firewall UFW: abrir puerto HTTP/HTTPS"
  echo " 14) üíæ Backup completo"
  echo " 15) ‚ôªÔ∏è  Restaurar backup"
  echo " 16) üîÑ Reload Nginx"
  echo " 17) ‚ôªÔ∏è  Restart Nginx"
  echo "  0) üö™ Salir"
  echo
}

main() {
  need_root
  read_cfg
  ensure_files
  rebuild_balancer_files >/dev/null 2>&1 || true
  write_apply_conf >/dev/null 2>&1 || true

  while true; do
    banner
    quick_status
    menu
    read -r -p "Opci√≥n: " opt
    echo
    case "$opt" in
      1) set_primary_domain; pause ;;
      2) add_backend; pause ;;
      3) add_other_domain; pause ;;
      4) list_backends_general; pause ;;
      6) delete_backend_pick; pause ;;
      7) healthcheck_all; pause ;;
      8) rate_limit_menu; pause ;;
      9) server_template_edit; pause ;;
      10) server_template_clone; pause ;;
      11) set_balance_mode; pause ;;
      12) traffic_menu; pause ;;
      13) ufw_open_port; pause ;;
      14) backup_bundle; pause ;;
      15) restore_bundle; pause ;;
      16) nginx_test_reload; echo -e "${GRN}‚úÖ Reload OK.${NC}"; pause ;;
      17) nginx -t && systemctl restart nginx; echo -e "${GRN}‚úÖ Restart OK.${NC}"; pause ;;
      0) exit 0 ;;
      *) echo -e "${YLW}Opci√≥n inv√°lida.${NC}"; pause ;;
    esac
  done
}

main
